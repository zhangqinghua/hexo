---
title: 附加

categories:
- 设计模式

date: 2020-08-18 00:00:01
---
## 摘要
设计模式可以理解为在一类特定环境中反复出现的一些问题，通过人们的发现和分析找出应对通用问题的解决措施。研究出的设计模式可以在软件开发上有极大的作用，因此起在软件工程中被得到大量的使用。[1]本文探讨了设计模式的起源、作用和基本要素，并从JDK和Spring的几个核心组件入手，试图找出构建JDK和Spring框架的骨骼架构，进而分析Spring在设计的一些设计理念，是否从中找出一些好的设计思想，对我们以后程序设计能提供一些思路。接着 再详细分析了它们是如何实现这些理念的，以及在设计模式上是如何使用的。

> 关键字：设计模式、JDK、Spring、工厂方法、策略模式

## 设计模式简介
#### 设计模式的产生背景
“设计模式”这个术语最初并不是出现在软件设计中，而是被用于建筑领域的设计中。

1977 年，美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造（A Pattern Language: Towns Building Construction）中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。

1979 年他的另一部经典著作《建筑的永恒之道》（The Timeless Way of Building）进一步强化了设计模式的思想，为后来的建筑设计指明了方向。

1987 年，肯特·贝克（Kent Beck）和沃德·坎宁安（Ward Cunningham）首先将克里斯托夫·亚历山大的模式思想应用在 Smalltalk 中的图形用户接口的生成中，但没有引起软件界的关注。

直到 1990 年，软件工程界才开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。

1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）一书，在本教程中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）匿名著称。

直到今天，狭义的设计模式还是本教程中所介绍的 23 种经典设计模式。

#### 设计模式的概念与意义
有关软件设计模式的定义很多，有些从模式的特点来说明，有些从模式的作用来说明。本教程给出的定义是大多数学者公认的，从以下两个方面来说明。

1. 软件设计模式的概念
软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。

1. 学习设计模式的意义
设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点。
可以提高程序员的思维能力、编程能力和设计能力。
使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。
使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。

当然，软件设计模式只是一个引导。在具体的软件幵发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，苛能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。

#### 设计模式的基本要素
软件设计模式使人们可以更加简单方便地复用成功的设计和体系结构，它通常包含以下几个基本要素：模式名称、别名、动机、问题、解决方案、效果、结构、模式角色、合作关系、实现方法、适用性、已知应用、例程、模式扩展和相关模式等，其中最关键的元素包括以下 4 个主要部分。

1. 模式名称
   每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。

1. 问题
   问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。

1. 解决方案
   模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的 组合）来解决这个问题。

1. 效果
   描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。

#### 设计模式的七大原则
设计模式有 7 个原则：单一职责原则、开闭原则、里氏替换原则、依赖倒转原则、接口隔离原则、合成/聚合复用原则、迪米特法则。接下来对这些原则一一进行讲解。

1. 单一职责原则
  单一职责原则又称为单一功能原则，它规定一个类只有一个职责。如果又多个职责（功能）被设计在一个类中，这个类就违反了单一职责原则。

1. 开闭原则
  开闭原则规定软件中的对象（类、模块、函数等）对扩展开放，对修改关闭。这意味着一个实体允许在不改变其源代码的前提下改动其行为。该特性在产品化的环境下是特别有价值的，在这种环境下，改变源代码需要经过代码审核、单元测试等过程，以确保产品的使用价值。遵循这个原则的代码在扩展时并不发生改变，因此不需要经历上述过程。

1. 里氏代换原则
  里氏代换原则是对开闭原则的补充，规定了在任意父类可以出现的地方，子类都一定可以出现。实现开闭原则的关键就是抽象化，父类和子类的继承关系就是抽象化的具体表现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

1. 依赖倒转原则
  依赖倒转原则指程序要依赖于抽象（比如 Java 中的抽象类和接口），而不依赖于具体的实现（比如 Java 中的实现类）。简单地说，就是要求基于抽象进行编程，不要求对实现进行编程。这就降低了模块直接的耦合度。

1. 接口隔离原则
  接口隔离原则指通过将不同的功能定义在不同的接口中来实现接口的隔离，这样就避免了其他类在依赖该接口（接口上定义的功能）时依赖其不需要的接口，可减少接口直接依赖的冗余性和复杂性。

1. 合成/聚合复用原则
  合成/聚合复用原则指通过在一个新的对象中引入（注入）已有的对象以达到类的功能复用和扩展的目的。它的设计原则是要尽量使用合成/聚合而不要使用继承来扩展类的功能。

1. 迪米特法则
  迪米特法则指一个对象尽可能少地与其他对象发生相互作用，即一个对象对其他对象应该有尽可能少的了解或依赖。其核心思想在于降低模块之间的耦合度，提高模块的内聚性。迪米特法则规定每个模块对其他模块都要有尽可能少的了解和依赖，因此很容易使系统模块直接功能独立，这使得各个模块的独立运行变得更简单，同时使得各个模块之间的组合变得更容易。

#### 设计模式的三大分类
设计模式按照其功能和使用创建可以分为三大类：创建型模式、结构型模式和行为型模式。

1. 创建型模式
  提供了许多优雅创建对象的方法，包含一下设计模式：工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式。

1. 结构型模式
  通过类和接口之间的继承和引用实现创建复杂结构对象的功能，包含：适配器模式、桥接模式、过滤器模式、组合模式、装饰器模式、外观模式、享元模式、代理模式。

1. 行为模式
  通过类之间不同的通信方式实现不同的行为方式，包括：责任链模式、命令模式、解析器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模版模式、访问者模式。

## JDK 中的设计模式
在JDK(Java Development Kit)类库中，开发人员使用了大量设计模式，正因为如此，我们可以在不修改JDK源码的前提下开发出自己的应用软件，研究JDK类库中的模式实例也不失为学习如何使用设计模式的一个好方式。

#### Runtime
每个Java应用程序都有一个Runtime类实例，它允许应用程序与运行应用程序的环境进行交互。可以从getRuntime方法获取当前运行时。Runtime使用了经典的单例模式结构，保证类只有一个实例，提供一个全局访问点。

![](http://hi.csdn.net/attachment/201101/3/0_1294058629PD9z.gif)

#### Collection
Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和Queue集合。

Iterator是Java集合框架的成员，但它与Collection系列、Map系列的集合不一样：Collection 系列集合、Map系列集合主要用于盛装其他对象，而Iterator则是主要用于遍历（即迭代访问）Collection 集合中的元素，Iterator对象也被称为迭代器。

Iterator的设计参考了工厂方法模式，具体实现由子类决定。

![](http://hi.csdn.net/attachment/201101/3/0_129405877799Eh.gif)

#### java.sql
java.sql提供使用JavaTM编程语言访问并处理存储在数据源（通常是一个关系数据库）中的数据的API。此API包括一个框架，凭借此框架可以动态地安装不同驱动程序来访问不同数据源。

java.sql使用了抽象工厂模式，此模式用于创建一个种类的对象，对于多数据源非常有用。

![](http://hi.csdn.net/attachment/201101/3/0_1294058833piFB.gif)

#### DocumentBuilder
DocumentBuilder用于从XML文档获取DOM文档实例。使用此类，应用程序员可以从 XML 获取一个 Document。

DocumentBuilder使用了建造者模式，此模式将构造逻辑提到单独的类中，并分离类的构造逻辑和表现。

![](http://hi.csdn.net/attachment/201101/3/0_1294058900z0nk.gif)

## Spring 中的设计模式
Spring是Java EE编程领域的一个轻量级开源框架，该框架由一个叫Rod Johnson的程序员在 2002 年最早提出并随后创建，是为了解决企业级编程开发中的复杂性，实现敏捷开发的应用型框架 。 [2]  Spring是一个开源容器框架，它集成各类型的工具，通过核心的Bean factory实现了底层的类的实例化和生命周期的管理。在整个框架中，各类型的功能被抽象成一个个的 Bean，这样就可以实现各种功能的管理，包括动态加载和切面编程。 [3]  Spring的设计使用了大量的设计模式。
#### Bean组件
Bean在Spring中作用就像Object对OOP的意义一样，没有对象的概念就像没有面向对象编程，Spring中没有Bean也就没有Spring存在的意义。就像一次演出舞台都准备好了但是却没有演员一样。

Spring Bean的创建是典型的工厂模式，他的顶级接口是BeanFactory，下图是这个工厂的继承层次关系：

![](http://images.51cto.com/files/uploadimg/20100611/1508522.png)

Bean组件在Spring的org.springframework.beans包下。这个包下的所有类主要解决了三件事：Bean的定义、Bean 的创建以及对Bean的解析。对Spring的使用者来说唯一需要关心的就是Bean的创建，其他两个由Spring在内部帮你完成了，对你来说是透明的。

#### Resource
Resource接口封装了各种可能的资源类型，也就是对使用者来说屏蔽了文件类型的不同。对资源的提供者来说，如何把资源包装起来交给其他人用这也是一个问题，我们看到Resource 接口继承了InputStreamSource接口，这个接口中有个getInputStream方法，返回的是InputStream类。这样所有的资源都被可以通过InputStream这个类来获取，所以也屏蔽了资源的提供者。

![](http://images.51cto.com/files/uploadimg/20100611/1508527.png)

从上图可以看出，Context是把资源的加载、解析和描述工作委托给了ResourcePatternResolver类来完成，他相当于一个接头人，他把资源的加载、解析和资源的定义整合在一起便于其他组件使用。 Core组件中还有很多类似的方式。

#### AopProxy
在Spring的AOP模块，一个主要的部分是代理对象的生成，可以通过AopProxy接口来完成，它封装了主要代理对象的生成过程。

AopProxy接口使用了策略模式，它可以据自身的条件选择不同的策略实现类来完成所要的操作。

![](http://images.51cto.com/files/uploadimg/20100611/15085222.png)

在上面结构图中与标准的策略模式结构稍微有点不同，这里抽象策略是AopProxy接口，Cglib2AopProxy和JdkDynamicAopProxy分别代表两种策略的实现方式，ProxyFactoryBean就是代表Context角色 ，它根据条件选择使用Jdk代理方式还是CGLIB方式，而另外三个类主要是来负责创建具体策略对象，ProxyFactoryBean是通过依赖的方法来关联具体策略对象的，它是通过调用策略对象的getProxy (ClassLoaderclassLoader)方法来完成操作。

## 结论
通过对JDK和Spring的分析，得到的一个很大的启示就是其这套设计理念其实对我们有很强的借鉴意义，它通过抽象复杂多变的对象，进一步做规范，然后根据它定义的这套规范设计出一个容器，容器中构建它们的复杂关系，其实现在有很多情况都可以用这种类似的处理方法。

设计模式在JDK和Spring中的广泛的应用，也从侧面反映了，对大项目的开发或者框架设计，用设计模式来组织代码显然更好。虽然设计模式的一些概念和具体操作比较抽象、难以理解，但如果能将其深入研究，就一定能对软件工厂领域起很大的帮助。同时也希望有关的研究人员能够越来越重视该问题。[2]

## 致谢
感觉老师一直以来催促我们完成学业。今年因为疫情的原因，过得很艰难，都想要放弃了，但最后还是坚定了下来。

在此，还要感谢在求学期间认识的所有同学和朋友们给予的帮助。

最后，我要感谢我的父母，是他们一直在背后默默地支持我。

## 参考文献
[1] 郑宇 . 面向Agent的软件设计模式. 贵州财经大学信息学院，2003(02): 160-163+173.
[2] 秦延锋，田涛.  浅谈设计模式的应用[J]. 软件园（产业聚焦），2013(03): 9-13.