---
title: 适配器模式

categories:
- 设计模式

date: 2020-08-18 00:00:55
---
适配器模式是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。

## 模式介绍
1. 举例说明
   美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。

   Java JDK 1.1 提供了 `Enumeration` 接口，而在 1.2 中提供了 `Iterator` 接口，想要使用 1.2 的 JDK，则要将以前系统的 `Enumeration` 接口转化为 `Iterator` 接口，这时就需要适配器模式。

1. 实际应用
   有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。

1. 意图目的
   将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

1. 主要解决
   主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。

1. 何时使用
   系统需要使用现有的类，而此类的接口不符合系统的需要。

   想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 

   通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）

1. 如何解决
   继承或依赖（推荐）。

1. 关键代码
   适配器继承或依赖已有的对象，实现想要的目标接口。

1. 优点
   灵活性好。

   提高了类的复用。 

   增加了类的透明度。

   可以让任何两个没有关联的类一起运行。

1. 缺点
   由于 Java 最多继承一个类，所以最多只能适配一个适配者类，而且目标类必须是抽象类。

   过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 

1. 注意事项
   适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。

## 代码实现
1、有一个媒体播放器，能播放音频格式。
```java
public class Demo {
    public static void main(String[] args) {
      // 播放器
      MediaPlayer player = new MediaPlayer();

      // 播放MP3
      Audio mp3 = new MP3();
      player.play(mp3);

      // 播放WAV
      Audio wav = new WAV();
      player.play(wav);
    }
}

// 播放器
public class MediaPlayer {
   public void play(Audio audioType) {
      System.out.println("Playing " + audioType.read() + "...");
   }
}

// 音频格式
public interface Audio {
   String read();
}

// MP3格式
public class MP3 implements Audio {
   public String read() {
      return "mp3 audio";
   }
}

// WVA格式
public class WAV implements Audio {
   public String read() {
      return "wav audio";
   }
}
```

2、现在要求支持播放视频格式（视频的音频部分）。

```java
public class Demo {
    public static void main(String[] args) {
      // 播放器
      MediaPlayer player = new MediaPlayer();

      // 播放MP3
      Audio mp3 = new MP3();
      player.play(mp3);

      // 播放WAV
      Audio wav = new WAV();
      player.play(wav);

      // 使用适配器播放MP4
      Video mp4 = new MP4();
      player.play(new AudioAdapter(mp4));

      // 使用适配器播放AVI
      Video avi = new AVI();
      player.play(new AudioAdapter(avi));
    }
}

// 新个视频格式
public interface Video {
   String readAudio();
   String readVideo();
}

public class MP4 implements Video {
   public String readAudio() {
      return "mp4 audio";
   }
   public String readVideo() {
      return "mp4 video";
   }
}
public class AVI implements Video {
   public String readAudio() {
      return "avi audio";
   }
   public String readVideo() {
      return "avi video";
   }
}

// 视频适配器
public class AudioAdapter implements Audio {
   private Video videoType;

   AudioAdapter(Video videoType) {
      this.videoType = videoType;
   }

   public String read() {
      return videoType.readAudio();
   }
}
```

另外一个例子：笔记本通过读卡去读取TF卡。

1、先模拟计算机读取 SD 卡。

```java
// 这里是使用方法
public class ComputerReadDemo {    
   public static void main(String[] args) {        
      Computer computer = new ThinkpadComputer();        
      SDCard sdCard = new SDCardImpl();       
      System.out.println(computer.readSD(sdCard));    
   }
}

// 这里是 SD 卡接口和实现
public interface SDCard {
   // 读取 SD 卡方法
   String readSD();
   // 写入 SD 卡功能
   int writeSD(String msg);
}
public class SDCardImpl implements SDCard {
   @Override    
   public String readSD() {
      String msg = "sdcard read a msg :hello word SD";
      return msg;  
   }
   @Override  
   public int writeSD(String msg) {      
      System.out.println("sd card write msg : " + msg);    
      return 1;   
   }
}

// 创建计算机接口，计算机提供读取SD卡方法
public interface Computer {    
    String readSD(SDCard sdCard);
}

public class ThinkpadComputer implements Computer {
   @Override    
   public String readSD(SDCard sdCard) {        
      if(sdCard == null)throw new NullPointerException("sd card null");        
      return sdCard.readSD();    
   }
}


```

2、接下来在不改变计算机读取SD卡接口的情况下，通过适配器模式读取TF卡。

```java
// 这里是使用方法
public class ComputerReadDemo {    
   public static void main(String[] args) {        
      Computer computer = new ThinkpadComputer();        
      SDCard sdCard = new SDCardImpl();        
      System.out.println(computer.readSD(sdCard));        
      System.out.println("====================================");        
      TFCard tfCard = new TFCardImpl();        
      SDCard tfCardAdapterSD = new SDAdapterTF(tfCard);        
      System.out.println(computer.readSD(tfCardAdapterSD));    
   }
}

// 创建TF卡接口
public interface TFCard {    
   String readTF();    
   int writeTF(String msg);
}

// 创建TF卡实例
public class TFCardImpl implements TFCard {    
   @Override    
   public String readTF() {        
      String msg ="tf card reade msg : hello word tf card";        
      return msg;    
   }    
   @Override    
   public int writeTF(String msg) {        
      System.out.println("tf card write a msg : " + msg);        
      return 1;    
   }
}

// 创建SD适配TF（也可以说是SD兼容TF，相当于读卡器）
public class SDAdapterTF implements SDCard {    
   private TFCard tfCard;    
   public SDAdapterTF(TFCard tfCard) {        
      this.tfCard = tfCard;    
   }    
   @Override    
   public String readSD() {        
      System.out.println("adapter read tf card ");        
      return tfCard.readTF();    
   }    
   @Override    
   public int writeSD(String msg) {        
      System.out.println("adapter write tf card");        
      return tfCard.writeTF(msg);    
   }
}
```

## JDK 中的适配器模式

## Spring 中的适配器模式