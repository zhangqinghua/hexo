---
title: 解释器模式

categories:
- 设计模式
- 行为型模式

date: 2020-08-18 00:00:45
---
在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解析器。

虽然使用解释器模式的实例不是很多，但对于满足以上特点，且对运行效率要求不是很高的应用实例，如果用解释器模式来实现，其效果是非常好的，本文将介绍其工作原理与使用方法。

## 模式介绍
1. 举例说明
    编译器。
    运算表达式。
    正则表达式。
    机器人。

1. 意图目的
    给定一个语言表达式，定义它的文法的一种表示，并定义一个解析器，使用该解释器来解释语言中的句子（表达式）。

    这里提到的文法和句子的概念同编译原理中的描述相同，“文法”指语言的语法规则，而“句子”是语言集中的元素。例如，汉语中的句子有很多，“我是中国人”是其中的一个句子，可以用一棵语法树来直观地描述语言中的句子。

1. 主要解决

1. 如何解决
    环境类：含有解释器之外的全局信息。
    客户端：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。
    抽象表达式：声明抽象的解释操作，这个方法为抽象语法树中的所有节点所共享。
    终结符表达式：实现与文法中的终结符相关的解释操作。
    非终结表达式：为文法中的非终结符实现解释操作。
    
1. 关键代码

1. 何时使用
    将一个需要解析执行的语言中的句子表示为一颗抽象语法树。

    一些重复出现的问题可以用一种简单的语言来表达。

    一个简单语法需要解释的场景。

1. 优点缺点
    扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。

    容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。

    执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。

    会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。

    可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。

1. 注意事项
    解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。如果碰到对表达式的解释，在 Java 中可以用 `Expression4J` 或 `Jep` 等来设计。

1. 应用场景
    自定义 JSON、XML 解释器。

    Spring 中的 `SpelExpressionParser`。

1. 模式扩展
    在项目开发中，如果要对数据表达式进行分析与计算，无须再用解释器模式进行设计了，Java 提供了以下强大的数学公式解析器：`Expression4J`、`MESP`(Math Expression String Parser) 和 `Jep` 等，它们可以解释一些复杂的文法，功能强大，使用简单。

## 模式的结构与实现
解释器模式常用于对简单语言的编译或分析实例中，为了掌握好它的结构与实现，必须先了解编译原理中的“文法、句子、语法树”等相关概念。

#### 文法
文法是用于描述语言的语法结构的形式规则。没有规矩不成方圆，例如，有些人认为完美爱情的准则是“相互吸引、感情专一、任何一方都没有恋爱经历”，虽然最后一条准则较苛刻，但任何事情都要有规则，语言也一样，不管它是机器语言还是自然语言，都有它自己的文法规则。例如，中文中的“句子”的文法如下。

```
〈句子〉::=〈主语〉〈谓语〉〈宾语〉
〈主语〉::=〈代词〉|〈名词〉
〈谓语〉::=〈动词〉
〈宾语〉::=〈代词〉|〈名词〉
〈代词〉你|我|他
〈名词〉7大学生I筱霞I英语
〈动词〉::=是|学习
```

> 注：这里的符号 ::= 表示“定义为”的意思，用“〈”和“〉”括住的是非终结符，没有括住的是终结符。

#### 句子
句子是语言的基本单位，是语言集中的一个元素，它由终结符构成，能由“文法”推导出。例如，上述文法可以推出“我是大学生”，所以它是句子。

#### 语法树
语法树是句子结构的一种树型表示，它代表了句子的推导结果，它有利于理解句子语法结构的层次。图 1 所示是“我是大学生”的语法树。

![](http://c.biancheng.net/uploads/allimg/181119/3-1Q119150550114.gif)

## 代码实现
四则运算问题：
1. 先输入表达式的形式，比如 a + b + c - d + e，要求表达式的字母不能重复。
1. 再分别输入 a、b、c、d、e 的值。
1. 最后得出结果。

传统方法：编写一个方法，接收表达式的形式，然后根据用户输入的数值进行解析，得到结果。

问题分析：如果加入新的运算符，比如 * / 等等，不利于扩展，另外让一个方法来解析会造成程序结构混乱，不够清晰。

解决方案：可以考虑使用解析器模式，即 表达式 -> 解析器 -> 结果。

## Spring 中的解析器模式
Spring 框架中的 `SpelExpressionParser` 就使用到了解释器模式。

