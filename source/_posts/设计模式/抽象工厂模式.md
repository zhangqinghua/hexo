---
title: 抽象工厂模式

categories:
- 设计模式

date: 2020-08-18 00:00:58
---
抽象工厂模式是围绕一个超级工厂创建子工厂。然后子工厂创建具体产品。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

## 模式介绍
1. 意图
    提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

1. 主要解决
    主要解决接口选择的问题。

1. 如何解决
    在一个产品族里，定义多个产品。

1. 何时使用
    系统的产品有多于一个的产品族，而系统只能消费其中某一族的产品。

1. 关键代码
    将产品分成工厂维度和产品类别维度。先生产工厂再生产产品。

1. 举例说明
    有鼠标、键盘、耳机3类产品，然后生产商家有惠普、戴尔、华硕 3 个工厂，合计 6 个种类的产品。我们可以分别按照工厂的维度和产品的维度去创建产品。

1. 优点
    降低选择困难症。

    当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

1. 缺点
    产品族扩展困难。详细看注意事项。

1. 使用场景
    鼠标、键盘、耳机 3 类产品，戴尔、惠普 2 个厂家共 6 类产品。戴尔、惠普、华硕 3 个厂家共 9 类产品。

    ？？？？

1. 注意事项
    产品（工厂）易扩展，产品族（产品类型）难扩展。

    比如在上面例子中，新增一个联想工厂，只需要新增一个工厂类。而新增笔记本产品，则需要在所有工厂类里面添加此产品。

    开闭原则。。。

## 代码实现
假设我们有鼠标、键盘、耳机3类产品，然后生产商家有惠普、戴尔、华硕 3 个工厂，合计 6 个种类的产品。

1.创建产品接口及其产品实例。

```java
public interface Mouse {
    void sayHi();
}
public interface Keybo {
    void sayHi();
}
public interface Earphone {
    void sayHi();
}

// ... 实现类
```

2.创建产品的工厂
```java
// 工厂接口
public interface PcFactory {
    Mouse createMouse();
    Keybo createKeybo();
    Earphone createEarphone();
}

// 惠普工厂
public class HpFactory implements PcFactory{

    @Override
    public Mouse createMouse() {
        return new HpMouse();
    }

    @Override
    public Keybo createKeybo() {
        return new HpKeybo();
    }

    @Override
    public Earphone createEarphone() {
        return new HpEarphone();
    }
}

// ... 其它工厂
```

3.生产工厂的工厂

```java
public class FactoryProducer {

    public static PcFactory hpFacotory() {
        return new HpFactory();
    }

    public static PcFactory dellFactory() {
        return new DellFactory();
    }

    public static PcFactory asusFactory() {
        return new AsusFactory();
    }
}
```

4.使用
```java
public class Demo {
    public static void main(String[] args) {
        // 创建惠普鼠标
        FactoryProducer.hpFacotory().createMouse();
        // 创建惠普键盘
        FactoryProducer.hpFacotory().createKeybo();
         // 创建惠普耳机
        FactoryProducer.hpFacotory().createEarphone();
        // 。。。戴尔、华硕产品
    }
}
```

可以看出，抽象工厂的本质是把产品分成2个维度，每个维度处理有限的产品，方便接口选择。

## JDK 源码

## Spring 源码