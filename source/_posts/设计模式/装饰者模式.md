---
title: 装饰者模式

categories:
- 设计模式

date: 2020-08-18 00:00:51
---
装饰者模式可以动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更加有弹性，装饰者模式也体现了开闭原则。

## 模式介绍
1. 举例说明
  装饰模式为已有类动态附加额外的功能就像 LOL、王者荣耀等类 Dota 游戏中，英雄升级一样。每次英雄升级都会附加一个额外技能点学习技能。具体的英雄就是ConcreteComponent，技能栏就是装饰器 Decorator，每个技能就是 ConcreteDecorator。

1. 模式原理
  装饰者模式分为主体角色（Component）和装饰角色（Decorator）。

  想象打包一个快递，主体就是陶瓷、衣服等，装饰就是报纸填充、塑料泡沫、纸板、木板。

  在星巴克例子中，主体就是各种咖啡，装饰就是各种调料。

1. 关键代码
  装饰者继承子主体，然后再持有一个主体，从而实现纸板包含塑料泡沫，塑料泡沫包含陶瓷的层次结构。

1. 何时使用
  多个装饰者，一个主体，递归关系。

## 代码实现
用户端使用效果。
```java
public class Demo {
    public static void main(String[] args) {
        // 购买长黑咖啡
        Drink drink = new LongBlack();
        // 添加牛奶调料
        drink = new Milk(drink);
        // 添加巧克力调料
        drink = new Chocolate(drink);

        // 打印账单
        System.out.println(drink.bill());
    }
}
巧克力：2.0 && 牛奶：3.0 && 长黑咖啡：20.0
```

1、创建主体角色及其子类。

```java
/**
 * 主体类
 */
@Data
public abstract class Drink {
    private String name;

    private Float price;

    public Drink(String name, Float price) {
        this.name = name;
        this.price = price;
    }

    /**
      * 打印订单信息，由子类实现
      */
    public abstract String bill();
}

/**
 * 主体实现，这里多一层封装。
 */
@Data
@EqualsAndHashCode(callSuper = true)
public class Coffee extends Drink {

    protected Coffee(String name, Float price) {
        super(name, price);
    }

    @Override
    public String bill() {
        return super.getName() + "：" + super.getPrice();
    }
}

/**
 * 具体产品
 */
public class LongBlack extends Coffee {

    public LongBlack() {
        super("长黑咖啡", 20f);
    }
}

public class Espresso extends Coffee {

    public Espresso() {
        super("浓缩咖啡", 30f);
    }
}
```

2、创建修饰者角色及其实现。

```java
/**
 * 调料抽象类，作为修饰者
 */
@Data
@EqualsAndHashCode(callSuper = true)
public abstract class Spices extends Drink {

    private Drink obj;

    protected Spices(String name, Float price, Drink obj) {
        super(name, price);
        this.obj = obj;
    }

    @Override
    public String bill() {
        return super.getName() + "：" + super.getPrice() + " && " + obj.bill();
    }
}

public class Milk extends Spices {

    public Milk(Drink obj) {
        super("牛奶", 3f, obj);
    }
}

public class Chocolate extends Spices {

    public Chocolate(Drink obj) {
        super("巧克力", 2f, obj);
    }
}
```

3、模拟新增一个无因咖啡。

```java
public class Decaf extends Coffee {

    public Decaf() {
        super("无因咖啡", 15f);
    }
}

public class Demo {
    public static void main(String[] args) {
        // 购买无因咖啡
        Drink drink = new Decaf();
        // 添加牛奶调料
        drink = new Milk(drink);

        // 添加巧克力调料
        drink = new Chocolate(drink);

        // 打印账单
        System.out.println(drink.bill());
    }
}

巧克力：2.0 && 牛奶：3.0 && 无因咖啡：15.0
```

## JDK 中的装饰者模式

JDK 中的 IO 结构就使用了装饰者模式。
1. `InputStream` 是主体角色。
1. `FileInputStream` 是主体实现。
1. `FilterInputStream` 是修饰者。
1. `DataInputStream`、`BufferInputStream` 是装饰者实现。

![](https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=152565344,2185255013&fm=15&gp=0.jpg)

```java
public class Demo2 {

    public static void main(String[] args) throws IOException {
        // 主体类，读取文件
        InputStream ios = new FileInputStream("/user/test.txt");
        // 装饰者，过滤数据
        ios = new DataInputStream(ios);

        System.out.println(ios.read());
    }
}

// 修饰者实现
public class DataInputStream extends FilterInputStream implements DataInput {
    public DataInputStream(InputStream in) {
        super(in);
    }
}

// 修饰者
public class FilterInputStream extends InputStream {
    protected volatile InputStream in;
}

// 主体类实现
public class FileInputStream extends InputStream {
}

// 主体类
public abstract class InputStream implements Closeable {
    public abstract int read() throws IOException;
}
```