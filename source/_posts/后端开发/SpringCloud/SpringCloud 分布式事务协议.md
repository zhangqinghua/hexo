---
title: SpringCloud 分布式事务协议

categories:
- 后端开发
- SpringCloud

date: 2021-02-17 00:00:01
---
在分布式系统中，每个节点都可以知晓自己操作的成功或者失败，却无法知道其它节点操作的成功或失败。当一个事务跨多个节点时，为了保持事务的原子性和一致性，而引入一个协调者来统一掌控所有参与者的操作结果，并指示它们是否要把操作结果进行真正的提交或者回滚。

## 二阶段提交
二阶段提交（Two-phase Commit，2PC）是常用的分布式事务解决方案，即将食物的提交过程分为两个阶段来进行处理。

阶段：
1. 准备阶段；
1. 提交阶段；

参与角色：
1. 协调者：事务的发起者；
1. 参与者：事务的执行者；


#### 第一阶段：投票阶段

#### 第二阶段：提交执行
当协调者从所有参与者节点获得相应的消息都为同意时：
1. 协调者节点向所有参与者节点发出“正式提交”的请求；
1. 参与者节点正式完成操作后，并释放在整个事务期间占用的资源；
1. 参与者节点向协调者节点发送 ack 完成消息；
1. 协调者节点收到所有参与者节点的反馈的 ack 完成消息后，完成事务；

#### 失败情况
如果任一参与者节点在第一阶段返回的响应消息为中止，或者协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：
1. 协调者节点向所有参与者节点发出“回滚操作”的请求；
1. 参与者节点利用阶段 1 写入的undo 信息执行回滚，并释放在整个事务期间内占用的资源；
1. 参与者节点向协调者节点发送 ack 回滚完成消息；
1. 协调者节点受到所有参与者节点反馈的 ack 回滚完成消息后，取消事务；

不管最后结果如何，第二阶段都会结束当前的事务。

#### 两阶段案例
学校运动会上，一百米决赛正准备开始，裁判对每个人分别询问：
1. 裁判：张三同学你准备好了吗？准备好了进第一赛道；
1. 张三：准备好了，随机进入第一赛道做好冲击姿势；
1. 裁判：李四同学你准备好了吗？准备好了进第二赛道；
1. 裁判：王五同学你准备好了吗？准备好了进第三赛道；
1. 李四：准备好了。。。
1. 王五：准备好了。。。
1. 。。。
1. 裁判：收到所有人的 OK 回复后，再次下令；
1. 裁判：跑。。。
1. 张三、李四执行完毕到达终点，汇报给裁判；
1. 王五冲刺失败，汇报给了裁判；

二阶段提交看起来确实能够提供原子性的操作，但是不幸的是，二阶段提交还是有几个缺点：
1. 性能问题
   执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其它第三方节点访问公共资源不得不处于阻塞状态； 
1. 可靠性问题
   参与者发送故障，协调者需要给每个参与者额外指定超时时间，超时后整个事务失败。协调者发生故障，参与者会一直阻塞下去。需要额外的备机进行容错。
1. 数据一致性问题
   协调者在发出 commit 消息后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否已经提交。

> 优点：尽量保证了数据的强一致性，适合对数据强一致性要求很高的关键领域（其实也不能 100% 保证强一致性）。

> 缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能的场景。

## 三阶段提交 3PC
三阶段提交协议，是二阶段提交协议的改进版本，三阶段提交有两个改动点：
1. 在协调者和参与者中都引入超时机制；
1. 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的；

也就是说，除了引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样三阶段提交就有了 canCommit、preCommit、doCommit 三个阶段。
