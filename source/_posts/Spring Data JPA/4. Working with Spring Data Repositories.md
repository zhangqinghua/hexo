---
title: 4. Working with Spring Data Repositories

categories:
- Spring Data JPA

date: 2018-07-08 23:24:58
---

The goal of the Spring Data repository abstraction is to significantly reduce the amount of boilderplate code required to implement data access layers for various persistence stores.

***Spring Data repository documentation and your module*
This chapter explains the core concepts and interfaces of Spring Data repositories. The information in this chapter is pulled from the Spring Data Commons module. It uses the configuration and code samples for the java Persistence API(JPA) module. You should adapt the XML namespace declaration and the types to be extended to the equivalents of the particular module that you use. "[Namespace reference](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repositories.namespace-reference)" convers XML configuration, which is supported across all Spring Data modules supporting the repository API. "[Repository query keyworks](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repository-query-keywords)" convers the query method keywords supported by the repository abstraction in general. For detailed information on the specific features of your module, see the chapter on that module on of this document.**

## Core concepts

The central interface in the Spring Data repository abstraction is `Repository`. It takes the domain class to manage as well as the ID type of the domain class as type arguments. This interface acts primarily as a marker interface to capture the types to work with and to help you to discover interfaces that extends this one. The `CrudRepository` provides sophisticated CRUD functionality for the entity class that is being managed.

*Example 3. `CrudRepository` interface*
```java
public interface CrudRepository<T, ID extends Serializable> extends Repository<T, ID> {

    // Saves the given entity.
    <S extends T> S save(S entity);

    // Returns the entity identified by the given ID.
    Optional<T> findById(ID primaryKey);

    // Returns all entities.
    Iterable<T> findAll();

    // Returns the number of entities.
    long count();

    // Deletes the given entity.
    void delete(T entity);

    // Indicates whether an entity with the given ID exists.
    boolean existsById(ID primary);

    // ... more functionality omitted.
}
```

**We alse provide persistence technology-specific abstraction as `JpaRepository` or `MongoRepository`. Those interfaces extend `CrudRepository` and expose the capabilities of the underlying persistence technology in addition to the rather generic persistence technology-agnostic interfaces such as `CrudRepository`.**

*Example 4. `PagingAndSortingRepository` interface*

```java
public interface PagingAndSortingRepository<T, ID extends Serializaable> extends CrudRepository<T, ID> {

    Iterable<T> findAll(Sort sort);

    Page<T> findAll(Pageable pageable);
}
```

To access the second page of `User` by a page size of 20, you could do something like the following:

```java
PagingAndSortingRepository<User, Long> repository = // ... get access to a bean

Page<User> users = repository.findAll(new PageRequest(1, 20));
```

In addition to query methods, query derivation for both count and delete queries is available. The following list shows the interface definition for a derived count query:

*Example 5. Derived Count Query*

```java
interface UserRepository extends CrudRepository<User, Long> {

    long countByLastname(String lastname);
}
```

The following list shows the interface definition for a derived delete query:

*Example 6. Derived Delete Query*

```java
interface UserRepository extends CrudRepository<User, Long> {

    long delteByLastname(String lastname);

    List<User> removeByLastname(String lastname);
}
```

## Query method

Standard CRUD funcitionality repositories usually have queries on the underlying datastore. With Spring Data, declaring those queries becomes a four-step process:

1. Declare an interface extending Repisotory or one of ites subinterfaces and type it to be domain class and ID type that it should handle, as shown in the following example:
    ```java
    interface PersonRepository extends Repository<Person, Long> {
        // ...
    }
    ```

1. Declare query methods on the interface:
    ```java
    interface PersonRepository extends Repository<Person, Long> {
        List<Persion> findByLastname(String lastname);
    }
    ```

1. Set up Spring to create proxy instance for those interfaces, either with [JavaConfig](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repositories.create-instances.java-config) or with [XML configuration](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repositories.create-instances). 
    - a. To use Java configuration, create a class similar to the following:
        ```java
        import org.springframework.data.jpa.repository.config.EnableJapRepositorise;

        @EnableJpaRepositorise
        class Config{}
        ```
    - b. To use XML configuration, define a bean similar to the following:
        ```xml
        <?xml version="1.0" encodeing="UTF-8"?>
        <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:jpa="http://www.springframework.org/schema/data/jpa"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
                            http://www.springframework.org/schema/beans/spring-beans.xsd
                            http://www.springframework.org/schema/data/jpa
                            http://www.springframework.org/schema/data/jpa/spring-jpa.xsd">
            <jpa:repositories base-package="com.acme.repositories"/>
        </beans>
        ```
    The JPA namespace is used in this example. If you use the repository abstraction for any other store, you need to change this to the appropriate namespace declaration of your store module. In other words, you should exchange jpa in favor of, of example, `mongodb`.

    \+ Also, note that the JavaConfig variant does not configure a package explicitly, because the package of the annotated class is used by defult. To customize the package to scan, use one of the `basePackage...` attributes of the data-store-specifiy repository's `@Enable${store}Repositories`-annotation.

1. Inject the repository instance and use it, as shown in the following example: 
    ```java
    Class SomeClient {
        private final PersonRepository repository;
        
        SomeClient(PersonRepository repository) {
            this.repository = repository;
        }

        void doSometing() {
            List<Person> persons = repository.findByLastname("Matthews");
        }
    }
    ```

The sctions that follow explain each step in detail:
- [Defining Repository interfaces](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repositories.definition)
- [Defining Query methods](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repositories.query-methods.details)
- [Creating Repository Instances](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repositories.create-instances)
- [Custom Implementations for Spring Data Repositories](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repositories.custom-implementations)

## Defining Repository interfaces

First, define a domain class-specific repository interface. The interface must extend `Repository` and be typed to the domain class and an ID type. If you want t expose CRUD methods for the domain type, extend `CrudRepository` instead of `Repository`.

### Fine-tuning Repository Definition

Typically, your repository interface extends `Repository`, `CrudRepository`, or `PagingAndSortingRepository`. Alternatively, if your do not want to extends Spring Data interfaces, you can also annotate your repository interface with `@RepositoryDefinition`. Extending `CrudRepository` exposes a complete set of methods to manipulate your entities. If you perfer to be selective about the methods being exposed, copy the methods you want to expose from `CrudRepository` into your domain repository.

> Doing so lets you define your own abstraction on top of the provided Spring Data Repositories functionaliy.

The following example shows how to selectively expose CRUD methods (`findById` and `save`, in this case): 

*Example 7. Selectively exposing CRUD methods*

```java
@NoRepositoryBean
interface MyBaseRepository<T, ID extends Serializable> extends Repository<T, ID> {

    Optional<T> findById(ID id);

    <S extends T> S save(S entity);
}

interface UserRepository extends MyBaseRepository<User, Long> {

    User findByEmailAddress(EmailAddress emailAddress);
}
```

In the prior example, you defined a common base interface for all your domain repositories and exposed `findById(...)` as well as `save(...)`. These methods are routed into the base repository implementation of the store of your choice provided by Spring Data (for example, if you use JPA, the implementation is `SimpleJpaRepository`), because they match the method signatures in `CrudRepository`, So the `UseRepository` can now save users, find individual suers by ID, and trigger a query to find `Users` by email address.

> The intermediate repository interface is annotated with `NoRepositoryBean`. Make sure you add that annotation to all repository interfaces for which Spring Data should not create instance at runtime.

### Null Handing of Repository Methods

As of Spring Data 2.0, repository CRUD methods that return an individual aggregate instance user Jave 8's `Optional` to indicate the potential absence of a value. Besides that, Spring Data supports returning the following wrapper types on query methods:

- `com.google.common.base.Optional`
- `scala.Option`
- `io.vavr.control.Option`
- `javaslang.control.Option` (deprecated as JavaConfig is deprecated)

Alternatively, query methods can choose not to use a wrapper type at all. The absence of a query result is then indicated by returning `null`. Repository methods returning collections, collection alternatives, wrappers, and streams are guaranteed never to return `null` but rather the corresponding empty representation. See [Repository query return types](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repository-query-return-types) for details. 

#### Nullability Annotations

You can express nullability constrains for repository methods by using [Spring Frameworkd's nullability annotations](https://docs.spring.io/spring/docs/5.0.7.RELEASE/spring-framework-reference/core.html#null-safety). They provide a tooling-friendly approach and opt-in `null` checks during runtime, as follows: 

- `@NonNullApi`: Used on the package level to declare that the defualt behavior for parameters and return values is to not accept or produce `null` values.
- `@NonNull`: Used on a parameter or return value that must not be `null` (not needed on a parameter and reutrn value where `@NonNullApi` applies).
- `@Nullable`: Used on a parameter or return value that can be `null`.

Spring annotations are meta-annotated with [JSR 305](https://jcp.org/en/jsr/detail?id=305) annotations (a dormant but widely spread JSR). JSR 305 meta-annotations let tooling vendors such as [IDEA](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html), [Eclipse](https://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.jdt.doc.user/tasks/task-using_external_null_annotations.htm), and [Kotlin](https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types) provide null-safety support in a generic way, without having to hard-code support for Spring annotations. To enable runtime checking of nullability constrains for query methods, you need to activate non-nullability on the package level by using Spring's `@NonNullApi` in `package-info.java`, as shown in the following example: 

*Example 8. Declaring Non-nullability in `package-info.java`*

```java
@org.springframework.lang.NonNullApi
package com.acme;
```

Once non-null defaulting is in place, repository query method invocations get validated at runtime for nullability constraints. If a query execution result vioaltes the defined contraints, an exception is thrown. This happens when the method would return `null` but is declared as non-nullable (the default with the annotation defined on the package the repository resides in). If you want to opt-in to nullable results again, selectively use `@Nullabel` on individual methods. Using the result wrapper types mentioned at the start of this section continues to work as expected: An empty result is trainslated into the value that represents absence.

The following example shows a number of the techniques just described: 

*Example 9. Using different nullability contraints*

```java
// The repository resides in a package (or sub-package) for which we have defined non-null behavior.
package com.acme;

import org.springframework.lang.Nullable;

interface UserRepository extends repository<User, Long> {

    // Throws an EmptyResultDataAccessException when the query executed does not produce a result. Throws an IllegalArgumentException when the emialAddress handed to the method is null.
    User getByEmailAddress(EmailAddress emailAddress);

    // Returns null when the query executed does not produce a result. Also accepts null as the value for emailAddress.
    @Nullable
    User findByEmailAddress(@Nullable EmailAddress emailAddress);

    // Returns Optional.empty() when the query executed does not produce a result. Throws an IllegalArgumentException when the emailAddress handed to the mothod is null. 
    Optional<User> findOptionalByEmailAddress(EmailAddress emailAddress);
}
```

#### Nullability in Kotlin-based Repositories

Kotlin has the definition of [nullability constraints](https://kotlinlang.org/docs/reference/null-safety.html) based into the language. Kotlin code compiles to bytecode, which does not express nullability contraints through method signatures but rather through compiled-in metadata. Make sure to include the `kotlin-reflect` JAR in your project to enable introspection of Kotlin's nullability constraints. Spring Data repositories use the language mechanism to define those contraints to apply the same runtime checks, as follows: 

*Example 10. Using nullability constraints on Kotlin repositories*

```kotlin
interface UserRepository : Repository<User, String> {

    // The method deines both the parameter and result as non-nullable (the Kotlin default). 
    // The Kotlin compiler rejects method invocations that pass null to the mothod. 
    // If the query execution yields an empty result, an EmptyResultDataAccessException is thrown.
    fun findByUsername(username: String): User

    // This moethod accepts null for the firstname parameter and return null if the query execution does not produce a result.
    fun findByFirstname(firstname: String?): User?
}
```

### Using Repositoies With Multiple Spring Data Modules

Using a unique Spring Data module in your application makes things simple, bacause all repository interface in the defined scope are bound to the Spring Data module. Sometimes, applications require using more than one Spring Data module. In such cases, a repository definition must distinguish between persistence technologies. When it detects muliple repository factories on the class path, Spring Data enters strict repository configuration mode. Strict configuration uses details on the repository or the domain class to decide about Spring Data module binding for a repository definition: 

1. If the repository definition [extends the module-specific repository](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repositories.multiple-modules.types), then it is a valid candidate for the particular Spring Data module.

1. If the domain class is [annotated with the module-specific type annotation](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repositories.multiple-modules.annotations), then it is a valid candidate for the particular Spring Data module. Spring Data modules accept either third-party annotations (such as JPA's `@Entity`) or provide their own annotations (such as `@Document` for Spring Data mongoDB and Spring Data Elasticsearh).

The following example shows a repository that uses module-specific interfaces (JPA in this case):

*Example 11. Repository definitions using module-specific interfaces*

```java
interface MyRepository extends JpaRepository<User, Long> {}

@NoRepositoryBean
interface MyBaseRepository<T, ID extends Serializable> extends JpaRepository<T, ID> {}

interface UserRepository extends MyBaseRepository<User, Long> {}
```

`Myrepository` and `UserRepository` extends `JpaRepository` in their type hierarchy. They are valid condidates for the Spring Data JPA module.

The following example shows a repository that use generic interfaces: 

*Example 12. Repository defintions using generic*

```java
interface AmbiguousRepository extends Repository<User, Long> {}

@NoRepositoryBean
interface MyBaseRepository<T, ID extends Serializable> extends CrudRepository<T, ID> {}

interface AmbiguousUserRepository extends MyBaseRepository<User, Long> {}
```

`AmbiguousRepository` and `AmbiguousUserRepository` extends by only `Repository` and `Curdrepository` in their type hierarchy. While this is perfectly fine when using a unique Spring Data module, multiple modules cannot distinguish to which particular Spring Data these repositories should be bound.

The following example shows a repository that uses domain classes with annotations: 

*Example 13. Repository definitions using domain classes with annotations*

```java
interface PersonRepository extends Repository<Person, Long> {}

@Entity
class Person {}

interface UserRepository extends Repository<User, Long> {}

@Document
class User {}
```

`PersonRepository` references `Person`, which is annotated with the JAP `@Entity` annotation, so this repository clearly belongs to Spring Data JPA. `UserRepository` references `User`, which is annotated with Spring Data MongoDB's `@Document` annotations.

The following bad example shows a repository that uses domain classes with mixed annotations: 

*Example 14. Repository definitions using domain classes with mixed annotations*

```java
interface JpaPersonRepository extends Repository<Person, Long> {}

interface MongoDBPersonRepository extends Repository<Person, Long> {}

@Entity
@Document
class Person {}
```

This example shows a domain class using both JPA and Spring Data MongoDB annotations. It defines two repositoies, `JpaPersonRepository` and `MongoDBPersonRepository`. One is intended for JPA and the other for MongoDB usage. Spring Data is no longer able to tell the repositoies apart, which leads to undefined behavior.

[Repository type details](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repositories.multiple-modules.types) and [distinguishing domain class annotations](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repositories.multiple-modules.annotations) are used for strict repository configuration to identify repository candidates for a particular Spring Data module. Using multiple persitence technology-specific annotations on the same domain type is possible and enables reuse of domain types across multiple persistence technologies. However, Spring Data can then no longer determine a unique module with which to bind the repository.

The last way to distingush repositoies is by scoping repository base packages. Base packages define the starting points for scanning for repository interface definitions. which implies having repository definitions located in the appropriate packages. By default, annotation-driven configuration uses the package of the configuration class. The [base package in XML-based configuration](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repositories.create-instances.spring) is mandatory.

the following example shows annotation-driven configuration of base packages: 

*Example 15 Annotation-driven configuration of base packages*

```java
@EnableJpaRepositories(basePackages = "com.acme.repositories.jpa")
@EnableMongoRepositories(basePackages = "com.acme.repositories.mongo")
interface Configuration {}
```

## Defining Query Methods

The repository proxy has two ways to derive a store-specific query from the method name: 

- By deriving the query from the method name directly.
- By using a manually defined query.

Available options depend on the actual store. However, there must be a strategy that decides what actual query is created. The next section describes the available options.

### Query Lookup Strategies

The following strategies are available for the repository infrastructure to resolve the query. With XML configuration, you can configure the strategy at the namespace through the `query-lookup-strategy` attributes. For Java configuration, you can use the `queryLookupStrategy` attribute of the `Enable${store}Repositories` annotation. Some strategies may not be supported for particular datastores.

- `CREATE` attempts to construct a store-specific query from the query method name. The general approach is to remove a given set of well known prefixes from the method name and parse the rest of the method. You can read more about query construction in [Query Create](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repositories.query-methods.query-creation).

- `USE_DECLARED_QUERY` tries to find a declared query and throws an exception if cannot find one. The query can be defined by an annotation somewhere or declared by oher means. Consult the documentation of the specific store to find available options for that store. If the repository infrastructure does not find a declared query for the method at bootstrap time, it fails.

- `CREATE_IF_NOT_FOUND` (default) combines `CREATE` and `USE_DECLARED_QUERY`. It tooks up a declared query first, and if no declard query if found, it creates a custom method name-based query. This is the defualt lookup strategy and, thus, is used if you do not configure anything explicity. It allows quick query definition by method names but also custom-tuning of these queries by introducing declared queries as needed.

### Query Create

The query builder mechanism built into Spring Data repository infrastructure is useful for building constraining queries over entities of the repository. The mechannism strips the prefixes `find...By`, `read...By`, `count...By`, and `get...By` for the method and starts parsing the rest of it. The introducing clause can contain further experssion, such as a `Distinct` to set a distinct flag on the query to be created. However, the frist `By` acts as delimiter to indicate the start of the actual criteria. At a very basic level, you can define conditions on entity properties and concatenate them with `And` and `Or`. The following example shows how to create a number of queries: 

*Example 16. Query creation from method names*

```java
interface PersonRepository extends Repository<User, Long> {
    List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);

    // Enable the distinct flag for the query
    List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String fristname);
    List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);

    // Enable ignoring case for an individual property
    List<Person> findByLastnameIngnoreCase(String lastname);
    // Enable ignoring case for all suitable properties
    List<Person> findByLastnameAndFirstnameAllIngnoreCase(String lastname, String firstname);

    // Enable static ORDER BY for a query
    List<person> findByLastnameOrderByFirstnameAsc(String lastname);
    List<Person> findByLastnameOrderByFirstnameDesc(String lastname);
}
```

The actual result of parsing the method depends on the persistence store for which you create query. However, there are some general things to notice: 

- The expression are usually property traversals combined with operators that concatenated. You can combine property expressions with `AND` and `OR`. You also get support for operators such as `Between`, `LessThan`, `GreaterThan`, and `Like` for the property expressions. The supported operators can vary by datastore, so consult the appropriate part of your reference documentation.

- The method parser supports setting an `IngnoreCase` flag for individual properties (for example, `findByLastnameIngnoreCase(...)`) or for all properties of a type that supports ingnoring case (usually `String` instances - for example, `findByLastnameAndFirstnameAllIngnoreCase(...)`). Whether ingoring cases is supported may vary by store, so consult the relevant sections in the reference documentation for the store-specific query method.

- You can apply static ordering by appending an `OrderBy` clause to the query method that references a property and by providing a sorting direction (`Asc` or `Desc`). To create a query method that supports dynamic sorting, see [Special parameter handling](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repositories.special-parameters).

### Property Expressions

Property expressions can refer to a direct property of the managed entity, as shown in the preceding example. At query creation time, you already make sure that the parsed property is a property of the managed domain class. However, you can also define constraints by traversing nested properties. Consider the following methods signatrue.

```java
List<Person> findByAddressZipCode(ZipCode zipCode);
```

Assume a `Perosn` has an `Address` with a `ZipCode`. In that case, the method creates the property traversal `x.address.zipCode`. the resolution algorithm starts by interpreting the entire part (`AddressZipCode`) as the property and checks the domain class for a property with that name (upcapitailzed). If the algorithm succeeds, it uses that property. If not, the algorithm splits up the source at the camel case parts from the right side into a head and a tail and tries to find the corresponding property - in our example, `AddressZip` and `Code`, if the algorithm finds a property with that head, it takes the tail and continues building the tree down from there, splitting the tail up in the way just described. If the first split does not match, the algorithm moves the split point to the left (`Address`, `ZipCode`) and continues.

Although this should work for most cases, it is possible for the algorithm to select the wrong property. Suppose the `Person` class has an `AddressZip` property as well. The algorithm would match in the frist split round already, choose the wrong property, and fail (as the type of `AddressZip` property has no `Code` property).

To resolve this ambiguity you can use `\_` inside your method name to manually define traversal points. So our method name would be as follows: 

```java
List<Person> findByAddress_ZipCode(ZipCode zipCode);
```

Because we treat the underscore character as a reserved character, we strongly advise following standard Java naming conventions (that is, not using underscores in property names but using camel case instead).

### Special paramter handling

To handle parameters in your query, define method paramaters as alreadly seen in the preceding examples. Besides that, the infrastructure recognize certain specific type like `Pageable` and `Sort`, to apply pagination and sorting to your queries dynamically. The following example demonstrates these features: 

*Example 17. Using `Pageable`, `Slice`, and `Sort` in query methods*

```java
Page<User> findByLastname(String lastname, Pageable pageable);

Slice<User> findByLastname(String lastname, Pageable pageable);

List<User> findByLastname(String lastname, Sort sort);

List<User> findByLastname(String lastname, Pageable pageable);
```

The first method lets you pass an `org.springframework.data.domain.Pageable` instance to the query method to dynamically add paging yo your statically defined query. A `Page` knows about the total number of elements and pages available. It does so by the infrastructure triggering a count query to calculate the overall number. As this might be expensive (depending on the store used), you can instead return a `Slice`. A `Slice` only knows about whether a next `Slice` is available, which might be sufficent when walking throught a larger result set.

Sorting options are handle through the `Pageable` instance, too. If you only need sorting, and an `org.springframework.data.domain.Sort` parameter to your method. As you can see, returning a `List` is possible. In this case, the additional metadata required to build the actual `Page` instance is not created (which, in turn, means that the additional count query that would have benn necessary is not issued). Rather, it restricts the query to look up only the given range of entities.

> To find out how many pages you get for an entire query, you have to trigger an additional count query. By default, this query is derived from the query you actually trigger.

### Limiting Query Results

The results of query methods can be limited by using the `first` or `top` keywords, which can be used interchangeably. An optional numeric value can be appended to `top` or `first` to specific the maximum result size to be returned. If the number is left out, a result size of 1 is assumed. The following example shows how to limit the query size: 

*Example 18. Limiting the result size of a query with `Top` and `Frist`*

```java
User findFirstByOrderByLastnameAsc();

User findTopByOrderByAgeDesc();

Page<User> queryFirst10ByLastname(String lastname, pageable);

Slice<User> findTop30ByLastname(String lastname, Pageable pageable);

List<User> findFirst10ByLastname(String lastname, Sort sort);

List<User> findTop10ByLastname(String lastname, Pageable pagealbe);
```

The limiting expressions also support the `Distinct` keyword. Also, for the queies limiting the result set to one instance, wrapping the result into with the `Optional` keyword is supported.

If pagination or slicing is applied to a limiting query pagination (and the calculation of the number of pages available), it is applied within the limited result.

> Limiting the results in combiantion with dynamic sorting by using a `Sort` parameter lets you express query methods for th 'K' smallest as well as for the `K` biggest elements.

### Streaming query results

The results of query methods can be processed is incrementally by using a Java 8 `Stream<T>` as return type. Instead of warpping the query result in a `Stream` data store-specific mehtods are used to perform the streaming. as shown in the following example: 

*Example 19. Stream the result of query with Java 8 `Stream<T>`*

```java
@Query("select u from User u")
Stream<User> findAllByCustomQueryAndStream();

Stream<User> readAllByFristnameNotNull();

@Query("select u from Use u")
Stream<User> streamAllPaged(Pagealbe pageable);
```

> A `Stream` potentially wraps underlying data store-specific resources and must, therefore, be closed after usage. You can either manually close the `Stream` by using the `Close()` method by using a Java 7 `try-catch-resources` block, as shown in the following example: 

*Example 20. Working with a `Stream<T>` result in a try-with-resources block*

```java
try (Stream<User> stream = repository.findAllByCustomQueryAndStream()) {
    stream.forEach(...);
}
```

> Not all Spring Data modules currently support `Stream<T>` as a return type.

### Async query results

Repository queries can be run asynchronously by using [Spring's asynchronous mehtod execution capability](https://docs.spring.io/spring/docs/5.0.7.RELEASE/spring-framework-reference/integration.html#scheduling). This means the method returns immediatey upon invocation while the actual query execution occurs in a task that has been submitted to Spring `TaskExecutor`. Asynchronous query execution is different from reactive query execution and should not be mixed. Refer to store-specific documentation for more details on reactive support. The following example shows a number of asynchronous queries: 

```java
// Use java.util.concurrent.Future as the return type
@Async
Future<User> findByFirstname(String firstname);

// Use a Java 8 java.util.concurrent.CompletableFuture as the return type.
@Async
CompletableFuture<User> findOneByFirstname(String firstname);

// Use a org.springframework.util.concurrent.ListenableFuture as the return type.
@Async
ListenableFuture<User> findOneByLastname(String lastname);
```

## Creating Repository Instances

In this section, you create instances and bean definitions for the defined repository interfaces. One way to do so is by using the Spring namespace that is shipped with each Spring Data module that supports the repository mechanism, although we generally recommend using Java configuration.

### XML configuration

Each Spring Data module includes a repositoies element that lets you define a base package that Spring scans for you, as shown in the following example: 

*Example 21. Enabling Spring Data repositories via XML*

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns:beans="http://www.springframework.org/schema/beans"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xmlns="http://www.springframework.org/schema/data/jpa"
             xsi:schemaLocation="http://www.springframework.org/schema/beans
             http://www.springframework.org/schema/beans/spring-beans.xsd
             http://www.springframework.org/schema/data/jpa
             http://www.springframework.org/schema/data/jpa/spring-jpa.xsd">

    <repositories base-package="com.acme.repositoies" />

</beans:beans>
```

In the preceding example, Spring is instructed to scan com.acme.repositories and all sub-packages for interfaces extending Repository or once of its sub-interfaces. For each interface found, the infrastructure register the persistence technology-specific FactoryBean to create the appropriate proxies that handle invocations of the query methods. Each bean is registered under a bean name that is derived from the interface name, so an interface of UserRepository would be registered under userRepository. The base-package attribute allows wildcards so that you can define a pattern of scanned packages.

#### Using filters

By default, the infrastructure picks up every interface extending the persistence technology-specific Repository sub-interface located under the configured base package and creates a bean instance for it. However, you might want more fine-grained control over which interfaces have bean instances created for them. To do so, use `<incule-filter/>` and `<exclude-filter/>` elements inside the `<repositories/>` element. The semantics are exactly equivalent to the elements in Spring's context namespace. For details, see the [Spring reference documentation](https://docs.spring.io/spring/docs/5.0.7.RELEASE/spring-framework-reference/core.html#beans-scanning-filters) fro these elements.

For example, to exclude certain interfaces from instantiation as repository beans, you would use the following configuration: 

*Example 22. Using exclude-fliter element*

```xml
<repositoies base-package="com.acme.repositoies">
    <context:exclude-filter type="regex" expression=".*SomeRepository">
</repositoies>
```

The preceding example excludes all interfaces ending in `SomeRepository` from being instantiated.

### JavaConfig

The repository infrastructure can also be triggered by using a store-specific `@Enable${store}Repositories` annotation on a JavaConfig class. For an introduction into Java-based configuration of the Spring container, see [JavaConfig in the Spring reference documentation](https://docs.spring.io/spring/docs/5.0.7.RELEASE/spring-framework-reference/core.html#beans-java).

A sample configuration to enable Spring Data repositoies resembles the following: 

*Example 23. Sample annotation based repository configuration*

```java
@Configuration
@EnableJpaRepositories("com.acme.repositories")
class ApplicationConfiguration {
    @Bean
    EntityManagerFactory entityManagerFactory() {
        // ...
    }
}
```

> The preceding example uses the JPA-specific annotation, which you would change according to the store module you actually use. The same applies to the definition of the `EntityManagerFactory` bean. See the sections covering the store-specific configuration.

### Standalone usage

You can also use the repository infrastructure outside of a Spring container - for example, in CDI environments. You still need some Spring libraries in your classpath, but, generally, you can set up repositories programmatically as well. The Spring Data modules that provide repository support ship a persistence technology-specific RepositoryFactory that you can use as follows: 

*Example 24. Standalone usage of repository factory*

```java
RepositoryFactorySupport factory = ... // Instantiate factory here
UserRepository repository = factory.getRepository(UserRepository.class);
```

## Custom Implementations for Spring Data Repositories

This section covers repository customization and how fragments form a composite repository.

When a query method requires a different behavior or cannot be implemented by query derivation, then it is necessary to provide a custom implementation. Spring Data repositories let you provide custom repository code and integrate it with generic CRUD abstraction and query method functionality.

### Customizing Individual Repositories

To enrich a repository with custom functionality, you must first define a fragment interface and an implementation for the custom functionality, as shown in the following example: 

*Example 25. Interface for custom repository functionality*

```java
interface CustomizedUserRepository {
    void someCustomMethod(User user);
}
```

Then you can let your repository interface additionally extend from fragment interface, as shown in the following example: 

*Example 26. Implementation of custom reposiotry functionality*

```java
class CustomizedUserRepositoryImpl implements CustomizedUserRepository {
    public void someCustomMethod(User user) {
        // Your custom implementation
    }
}
```

> The most important part of the class name that corresponds to the fragment interface is the `Impl` postifx.

The implementation itself does not depend on Spring Data and can be a regular Spring bean. Consequently, you can use standard dependency injection behavior to inject references to other beans (such as a `JdbcTemplate`), take part in aspects, and so on.

You can let your repository interface extend the fragment interface, as shown in the following example: 

*Example 27. Changes to your repository interface*

```java
interface UserRepository extends CrudRepository<User, Long>, CustomizedUserRepository {
    // Declare query methods here
}
```

Extending the fragment interface with your repository interface combines the CRUD and custom functionality and makes it available to clients.

Spring Data repositories are implemented by using fragments that form a repository composition. Fragments are the base repository, functional aspects (such as [QueryDsl](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#core.extensions.querydsl)), and custom interfaces along with their implementaion. Each time you add an interface to your repository interface, you enhance the composition by adding a fragment. The base repository and repository aspect implementations are provided by each Spring Data module.

The following example shows custom interfaces and their implementations: 

*Example 28. Fragments with their implementations*

```java
interface HumanRepository {
    void someHumanMethod(User user);
}

class HumanRepositoryImpl implements HumanRepository {
    public void someHumanMethod(User user) {
        // Your custom implementation
    }
}

interface ContactRepository {
    void someContactMethod(User user);

    User anotherContactMethod(User user);
}

class ContactRepositoryImple implements ContactRepository {
    public void someContactMethod(User user) {
        // Your custom implementation
    }

    public User anotherContactMethod(User user) {
        // Your custom implementation
    }
}
```

The following example shows the interface for a custom repository that extends CrudRepository: 

*Example 29. Changes to your repository interface*

```java
interface UserRepository extends Crudrepository<User, Long>, HumanRepository, ContactRepository {
    // Declare query methods here
}
```

Repositories may be composed of multiple custom implementations that are imported in the order of their declaration. Custom implementations have a higher priority than the base implementation and repository aspects. This ordering lets you override base repository and aspect methods and resolves ambiguity if two fragments contribute the same method signature. Repository fragments are not limited to use in a single repository interface. Multiple repositoies may use a fragment interface, letting you reuse customizations across different repositories.

The following example shows a repository fragment and its implementation: 

*Example 30. Fragments overriding `save(...)`*

```java
interface CustomizedSave<T> {
    <S extends T> S save(S entity);
}

class CustomizedSaveImpl<T> implements CustomizedSave<T> {
    public <S extends T> S save(S entity) {
        // Your custom implementation
    }
}
```

The following example shows a repository that uses the preceding repository fragment: 

*Example 31. Customized repository interfaces*

```java
interface UserRepository extends CrudRepository<User, Long>, CustomizedSave<User> {

}

interface PersonRepository extends CrudRepository<Person, Long>, CustomizedSave<Person> {

}
```

#### Configuration

If you use namespace configuration, the repository infrastructure tries to autodetect custom implementation fragments by scanning for classes below the package in which it found a repository. These classes need to follow the naming convention of appending the namespace element's `repository-impl-postfix` attribute to the fragment interface name. This postfix defaults to `Impl`. The following example shows a repository that uses the default postfix and a repository that sets a custom value for the postfix: 

*Example 32. Configuration example*

```xml
<repositories base-package="com.acme.repository" />
<repositories base-package="com.acme.repository" repository-impl-postfix="MyPostfix">
```

The first configuration in the preceding example tries to look up a class called `com.acme.repository.CustomizedUserRepositoryImpl` to act as a custom repository implementation. The second example tries to lookup `com.acme.repository.CustomizedUserRepositoryMyPostfix`.

##### Resolution of Ambiguity

If multiple implementations with matching class names are found in different packages, Spring Data uses the bean names to identify which one to use.

Given the following two custom implementations for the `CustomizedUserRepository` shown earlier, the first implementation is used. Its bean name is `CustomizedUserRepositoryImpl`, which matches that of the fragment interface (`CustomizedUserRepository`) plus the postfix `Impl`.

*Example 33. Resolution of amibiguous implementations*

```java
package com.acme.impl.one;

class CustomizedUserRepositoryImpl implements CustomizedUserRopository {
    // Your custom implementation
}
```

```java
package com.acme.impl.two;

@Component("specialCustomImpl")
class CustomizedUserRepositoryImpl implements CustomizedUserRepository {
    // Your custom implementation
}
```

If you annotate the `UserRepository` interface with `@Component("specialCustom")`, the bean name plus `Impl` then matches the one defined for the repository implementation in `com.acme.impl.two`, and it is used instead of the first one.

##### Manual Wiring

If you custom implementation uses annotation-based confirguration and autowiring only, the preceding approach shown works well, because it is treated as any other Spring Data bean. If your implementation fragment bean needs specific wiring, you can declare the bean and name it according to the conventions described in the [preceding section](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repositories.single-repository-behaviour.ambiguity). The infrastructure then refers to the manually defined bean definition by name instead of creating one iteself. The following example show how to manually wire a custom implementaiton: 

*Example 34. Manual wiring of custom implementations*

```xml
<repositories base-package="com.acme.repository" />

<beans:bean id="userRepositoryImpl" class="...">
    <!-- further configuration -->
</beans:bean>
```

### Customize the Base Repository

The approach described in the [preceding section](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repositories.manual-wiring) requires customization of each repository interfaces when you want to customize the base repository behavior so that all repositories are affected. To instead change behavior for all repositories, you can create an implementation that extends the persistence technology-specific repository base class. This class then acts a custom base class for the repository proxies, as shown in the following example: 

*Example 35. Custom repository base class*

```java
class MyRepositoryImpl<T, ID extends Serializable> extends SimpleJparepository<T, ID> {
    private final EntityManager entityManager;

    MyRepositoryImpl(JpaEntityInformation entityInformation, EntityManager entityManager) {
        super(entityInformation, entityManager);

        // Keep the EntityManager around to used from the newly introduced methods
        this.entityManager = entityManager; 
    }

    @Transactional
    public <S extends T> S save(S entity) {
        // implementation goes here
    }
}
```

> The class needs to have a constructor of the super class which the store-specific repository factory implementation uses. If the repository base class has multiple constructors, override the one taking an `EntityInformation` plus a store specific infrastructure object (such as an `EntityManager` or a template class).

The final step is to make the Spring Data infrastructure aware of the customized repository base class. In Java configuration, you can do so by using the `repositoryBaseClass` attribute of the `@Enable${store}Repositories` annotation, as shown in the following example: 

*Example 36. Configuring a custom repository base class using JavaConfig*

```java
@Configuration
@EnableJpaRepositoies(repositoryBaseClass = MyRepositoryImpl.class)
class ApplicationConfiguration {
    // ...
}
```

A corresponding attribute is available in the XML namespace, as shown in the following example: 

*Example 37. Configuring a custom repository base class using XML*

```xml
<repositorise base-package="com.acme.repository" base-class="....MyRepositoryImpl" />
```

## Publishing Events from Aggregate Roots

Entities managed by repositories are aggregate roots. In a Domain-Driven Design application, these aggregate roots usually publish domain envents. Spring Data provides an annotation called `@DomainEvents` that you can use on a method of your aggregate root to make that publication as easy as possible, as shown in the following example: 

*Example 38. Exposing domain events from an aggregate root*

```java
class AnAggregateRoot {
    
    // The method using @DomainEvents can return either a single event instance or a collection of events. Is must not take any arguments. 
    @DomainEvents
    Collection<Object> domainEvents() {
        // ... return events you want to get published here
    }

    // After all events have been published, we have a method annotated with @AfterDomainEventPublication. It can be used to potentially clean the list of events to be published (among other uses).
    @AfterDomainEventPublication
    void callbackMethod() {
        // ... potentially clean up domain events list
    }
}
```

The methods are called every time one of a Spring Data repository's `save(...)` methods is called.

## Spring Data Extensions

The section documents a set of Spring Data extensions that enable Spring Data usage in a variety of context. Currently, most of the integration is targetd towards Spring MVC.

### QueryDsl Extension

[Querydsl](http://www.querydsl.com/) is a framework that enables the construction of statically typed SQL-like queries through its fluent API.

Several Spring Data modules offer integration with Querydsl through `QuerydslPredicateExecutor`, as shown in the following example: 

*Example 39. `QuerydslPredicateExecutor` interface*

```java
public interface QuerydslPredicateExecutor<T> {

    // Finds and returns a single entity matching the Predicate.
    Optional<T> findById(Predicate predicate);

    // Finds and returns all entities matching the Predicate.
    Iterable<T> findAll(Predicate predicate);

    // Returns the number of entities matching the Predicate.
    long count(Predicate predicate);

    // Returns whether an entity that matches the Predicate exists.
    boolean exists(Predicate predicate);
}
```

To make use of Querydsl support, extends `QuerydslPredicateExecutor` on your repository interface, as shown in the following example: 

*Example 40. Querydsl integration on repositories*

```java
interface UserRepository extends CrudRepository<User, Long>, QuerydslPredicateExecutor<User> {

}
```

The preceding example lets you write typesafe queries using Querydsl `Predicate` instances, as shown in the following example: 

```java
Predicate predicate = user.firstname.equalsIgnoreCase("dava").and(user.lastnam.startWithIgnoreCase("mathews"));

userRepository.findAll(predicate);
```

### Web support

> This section contains the documentation for the Spring Data web support as it is implemented in the current (and later) versions of Spring Data Commons. As the newly introduced support changes many things, we kept the documentation of the former behavior in [web.legacy](https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#web.legacy).

Spring Data modules that support the repository programming model ship  with a variety of web support. The web related components require Spring MVC JARs to be on the classpath. Some of them even provide integration with [Spring HATEOAS](https://github.com/SpringSource/spring-hateoas). In general, the integration support is enabled by using the `@EnableSpringDataWebSupport` annotation in your JavaConfig configuration class, as shown in the following example: 

*Example 41. Enabling Spring Data web support*

```java
@Configuration
@EnableWebMvc
@EnableSpringDataWebSupport
class WebConfiguration {

}
```

The `@EnableSpringDataWebSupport` annotation registers a few components we will discuss in a bit. It will also detect Spring HATEOAS on the classpath an register integration components for it as well if present.

Alternatively, is you use XML configuration, register either `SpringDataWebConfiguration` or `HateoasAwareSpringDataWebConfiguration` as Spring beans, as shown in the following example (for `SpringDataWebConfiguration`): 

*Example 42. Enabling Spring Data web support in XML*

```xml
<bean class="">
```