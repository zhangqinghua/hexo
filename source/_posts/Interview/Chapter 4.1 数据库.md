---
title: Chapter 4.1 数据库

categories:
- Interview

date: 2020-04-28 00:00:41
---

#### 什么是数据库

## 索引
#### 什么是索引
一个索引是存储的表中一个特定列的值数据结构（最常见的是 B-Tree），索引是在表的列上创建。所以，要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中。

请记住记住这一点：索引是一种数据结构。

#### 索引的实现
MySQL 目前主要有以下几种索引实现：HASH、BTREE，RTREE、FULLTEXT。
- HASH
    由于 HASH 的唯一（几乎 100% 的唯一）及类似键值对的形式，很适合作为索引。
    HASH 索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。
- BTREE
    BTREE 索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口 root 开始，依次遍历 node，获取 leaf。这是 MySQL 里默认和最常用的索引类型。
- RTREE
    RTREE 在 MySQL 很少使用，仅支持 geometry 数据类型，支持该类型的存储引擎只有 MyISAM、BDb、InnoDb、NDb、Archive 几种。
- FULLTEXT
    全文索引

#### 索引的种类
- 普通索引
    在 MySQL 中执行查询时，只能使用一个索引。如果我们在多个字段上分别建索引，执行查询时，MySQL 会选择一个最严格（获得结果集记录数最少）的索引。
- 唯一索引
    类似普通索引，索引列的值必须唯一（可以为空，这点和主键索引不同）
- 主键索引
    特殊的唯一索引，不允许为空，只能有一个，一般是在建表时指定
- 组合索引
    在多个字段上创建索引，遵循最左前缀原则，就是最左优先，先要看第一列，在第一列满足的条件下再看左边第二列，以此类推。
    ```sql
    create table test(
        id1 int ,
        id2 int,
        id3 int,
        id4 int,
        key index_id12(id1,id2));

    # 用到索引
    explain select * from test where id1 < 10;
    # 用到索引
    explain select * from test where id1 < 10 and id2 > 1; 
    # 用到索引
    explain select * from test where id2 > 1 and id1 < 2; 
    # 未用到索引
    explain select * from test where id2 > 1;
    # 未用到索引
    explain select * from test order by id1 desc ;
    # 用到索引
    explain select id1 from test order by id1 desc ;
    explain select id1,id2 from test order by id1 desc ;
    # 未用到索引
    explain select id1,id2,id3 from test order by id1 desc ;
    ```
- 全文索引
    即为全文索引，目前只有 MyISAM 引擎支持。其可以在 CREATE TABLE、ALTER TABLE、CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR、TEXT 列上可以创建全文索引。

    全文索引并不是和 MyISAM 一起诞生的，它的出现是为了解决 WHERE name LIKE “%word%" 这类针对文本的模糊查询效率较低的问题。
    
#### 何时使用索引
- 主键、unique字段
- 和其他表做连接的字段（或者说外建）需要加索引
- 在 where 里使用 ＞，≥，＝，＜，≤，is null和 between 等字段
- 使用不以通配符开始的 like，例如 where A like 'China%'
- 聚集函数 min()，max() 中的字段
- order by 和 group by 字段

#### 何时不使用索引
- 表中记录较少
- 不作为 where 查询条件时
- 数据重复且分布平均的字段（只有很少数据值的列）
- 经常插入、删除、修改的表要减少索引
- text，image 等类型不应该建立索引，这些列的数据量大

#### 索引何时失效
- 组合索引未使用最左前缀，例如组合索引（A，B），where B = b 不会使用索引
- like 未使用最左前缀，where A like '%China'
- 搜索一个索引而在另一个索引上做 order by，where A = a order by B，只使用 A 上的索引，因为查询只使用一个索引
- or 会使索引失效。如果查询字段相同，也可以使用索引。例如where A = a1 or A = a2（生效），where A = a or B = b（失效）
- 如果列类型是字符串，要使用引号。例如 where A='China'，否则索引失效（会进行类型转换）
- 在索引列上的操作，函数（upper() 等）、or、!=、<>、not in 等

#### 索引会不会使插入、删除效率变低？怎么解决
- insert 的过程是，先把数据插入到表中，然后再把数据插入到相关索引中，如果这个表有 5 个索引，那么就得维护这 5 个索引，不管这个插入的数据是否为 NULL 值。
- delete 操作刚好和 isnert 相反，当删除一条数据时，会把这条数据涉及到的多个索引中的数据删除。
- update 操作不同于 insert、delete，只有当 update 的这个字段，涉及到索引时，才需要维护索引，相对来说开销要小一些。

## 事务
#### 什么是事务
事务就是作为单个逻辑单元执行的一组操作，要么全部成功，要么全部失败。

#### 事务的特点是什么
事务特性分为四个：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持续性（Durability）简称 ACID。

- 原子性：事务是数据库逻辑工作单元，事务中包含的操作要么都执行成功，要么都执行失败。
- 一致性：事务执行的结果必须是使数据库数据从一个一致性状态变到另外一种一致性状态。当事务执行成功后就说数据库处于一致性状态。如果在执行过程中发生错误，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这是数据库就处于不一致状态。
- 隔离性：一个事务的执行过程中不能影响到其他事务的执行，即一个事务内部的操作及使用的数据对其他事务是隔离的，并发执行各个事务之间无不干扰。
- 持续性：即一个事务执一旦提交，它对数据库数据的改变是永久性的。之后的其它操作不应该对其执行结果有任何影响。

#### 事务的隔离级别有哪些
事务的隔离级别也分为四种，由低到高依次分别为：read uncommited（读未提交）、read commited（读提交）、read repeatable（读重复）、serializable（序列化），这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。

![](https://images2015.cnblogs.com/blog/1053956/201703/1053956-20170313102548791-1506111244.png)

- read uncommited：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。
- read commited：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。
- peatable read：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻象读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了以下情况产生（不可重复读）。
- serializable：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读。

#### 什么是脏读
指当一个事务正在访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的。

#### 什么是幻读
一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻象读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）

#### 什么是不可重复读
指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。

#### 什么是事务传播
事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。

#### Spring 支持哪些事务传播行为
Spring 支持 7 种事务传播行为：
- propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。
- propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。
- propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。
- propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。
- propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
- propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。
- propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 propagation_required 类似的操作。

Spring 默认的事务传播行为是 propagation_requierd，它适合于绝大多数的情况。假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1() -> Service2#method2() -> Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。