---
title: Chapter 4.4 Redis

categories:
- Interview

date: 2020-04-28 00:00:44
---
#### Redis 是什么
Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的API。

它通常被称为数据结构服务器，因为值（value）可以是 字符串, 哈希, 列表, 集合和有序集合等类型。

#### Redis 的特点
- 持久化：Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
- 多数据类型：Redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list、set、zset、hash 等数据结构的存储。
- 集群：Redis支持数据的备份，即 master-slave 模式的数据备份。
- 高性能：Redis 读的速度是 110000 次/s,写的速度是 81000 次/s。

#### Redis 有什么用
项目中使用 Redis 的，主要是从两个角度去考虑：性能、并发。当然，Redis 的的的还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件代替，并不是非要使用 Redis 的的的。因此，这个问题主要从性能和并发两个角度去答。

- 性能
    我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存，这样，后面的请求就去缓存中读取，请求使得能够迅速响应。
    ![](https://img-blog.csdn.net/20180725153216223?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODQ2NTYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 并发  
    在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用的的 Redis 的做一个缓冲操作，让请求先访问到的 Redis 的，而不是直接访问数据库。
    ![](https://img-blog.csdn.net/20180725153422311?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODQ2NTYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### Redis 是单线程的还是多线程的
Redis 是单线程。Redis 之所以可以快速执行这也是一部分原因：
- 绝大部分请求是纯粹的内存操作（非常快速）
- 采用单线程,避免了不必要的上下文切换和竞争条件
- 非阻塞 IO - IO 多路复用

## 持久化
#### 为什么需要持久化
由于 Redis 的数据都存放在内存中，如果没有配置持久化，Redis 重启后数据就全丢失了，于是需要开启 Redis 的持久化功能，将数据保存到磁盘上，当 Redis 重启后，可以从磁盘中恢复数据。

#### Redis 的持久化操作有哪些
Redis 提供两种方式进行持久化，一种是 RDB 持久化（原理是将 Redis 在内存中的数据库记录定时 dump 到磁盘上），另外一种是 AOF（append only file）持久化（原理是将 Redis 的操作日志以追加的方式写入文件）。

#### RDB 和 AOF 的区别
RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是 fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。

![](https://images2017.cnblogs.com/blog/388326/201707/388326-20170726161552843-904424952.png)

AOF 持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。

![](https://images2017.cnblogs.com/blog/388326/201707/388326-20170726161604968-371688235.png)


#### RDB 持久化配置
Redis 会将数据集的快照 dump 到 dump.rdb 文件中。此外，我们也可以通过配置文件来修改 Redis 服务器 dump 快照的频率，在打开6379.conf文件之后，我们搜索 save，可以看到下面的配置信息：
```
save 900 1      # 在 900 秒(15 分钟)之后，如果至少有 1 个 key 发生变化，则 dump 内存快照
save 300 10     # 在 300 秒(5 分钟)之后，如果至少有 10 个 key 发生变化，则 dump 内存快照
save 60  10000  # 在 60 秒(1 分钟)之后，如果至少有 10000 个 key 发生变化，则 dump 内存快照
```
#### AOF 持久化配置
在 Redis 的配置文件中存在三种同步方式，它们分别是：
```
appendfsync no          # 从不同步。高效但是数据不会被持久化。
appendfsync always      # 每次有数据修改发生时都会写入 AOF 文件。
appendfsync everysec    # 每秒钟同步一次，该策略为 AOF 的缺省策略。
```

#### RDB 的优缺点
- 一旦采用该方式，那么你的整个 Redis 数据库将只包含一个文件，这对于文件备份而言是非常完美的。对于灾难恢复而言，RDB 是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。
- 性能最大化。对于 Redis 的服务进程而言，在开始持久化时，它唯一需要做的只是 fork 出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行 IO 操作了。相比于 AOF 机制，如果数据集很大，RDB 的启动效率会更高。
- 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么 RDB 将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。
- 由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是 1 秒钟。

#### AOF 的优缺点
- 该机制可以带来更高的数据安全性，即数据持久性。
- 由于该机制对日志文件的写入操作采用的是 append 模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。
- 如果日志过大，Redis 可以自动启用 rewrite 机制。即 Redis 以 append 模式不断的将修改数据写入到老的磁盘文件中，同时 Redis 还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行 rewrite 切换时可以更好的保证数据安全性。
- AOF 包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。
- 体积大：对于相同数量的数据集而言，AOF 文件通常要大于 RDB 文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。
- 效率慢：根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和 RDB 一样高效。

## 热数据
#### 什么是热数据

#### 如何利用 Redis 处理热数据
- 凭借业务经验，进行预估哪些是热 key
- 

## 热 key
#### 什么是热 key 问题
所谓热key问题就是，突然有几十万的请求去访问 Redis 上的某个特定 key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台Redis的服务器宕机。

那接下来这个 key 的请求，就会直接怼到你的数据库上，导致你的服务不可用。

#### 怎么发现热 key
- 凭借业务经验，进行预估哪些是热 key
    其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的 key 就可以判断出是热 key。缺点很明显，并非所有业务都能预估出哪些 key 是热 key。
- 在客户端进行收集
    这个方式就是在操作 Redis 之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。
- 在 Proxy 层做收集
    有些集群架构是下面这样的，Proxy 可以是 Twemproxy，是统一的入口。可以在 Proxy 层做收集上报，但是缺点很明显，并非所有的 Redis 集群架构都有 Proxy。
- 用 Redis 自带命令
    - monitor 命令，该命令可以实时抓取出 Redis 服务器接收到的命令，然后写代码统计出热 key 是啥。当然，也有现成的分析工具可以给你使用，比如 Redis-faina。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低 Redis 的性能。
    - hotkeys参数，Redis 4.0.3 提供了 Redis-cli 的热点 key 发现功能，执行 Redis-cli 时加上 –hotkeys 选项即可。但是该参数在执行的时候，如果 key 比较多，执行起来比较慢。
- 自己抓包评估
    Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。

## 集群
#### Redis 的分布式集群怎么做
- Redis 官方集群方案 Redis Cluster
- Redis Sharding 集群
- 利用代理中间件实现大规模Redis集群

#### 什么是缓存雪崩
由于原有缓存失效（或者数据未加载到缓存中），新缓存未到期间（缓存正常从 Redis 中获取，如下图）所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机，造成系统的崩溃。

缓存雪崩过程：
- Redis 集群大面积故障
- 缓存失效，但依然大量请求访问缓存服务 Redis
- Redis 大量失效后，大量请求转向到 MySQL 数据库
- Mysql 的调用量暴增，很快就扛不住了，甚至直接宕机
- 由于大量的应用服务依赖 MySql 和 Redis 的服务，这个时候很快会演变成各服务器集群的雪崩，最后网站彻底崩溃

#### 如何预防缓存雪崩
一般我们可以通过设计缓存的高可用性，缓存降级，Redis 备份和快速预热，也可以在上线前提前演练。

- 缓存的高可用性
    缓存层设计成高可用，防止缓存大面积故障。即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如 Redis Sentinel 和 Redis Cluster 等 Redis 集群都实现了高可用。
- 缓存降级

- Redis 备份和快速预热
    Redis数据备份和恢复，快速缓存预热
- 提前演练
    在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，对高可用提前预演，提前发现问题。

## 高并发方案
#### 流量削峰的由来
比如说秒杀活动，短时间内大量用户涌入，瞬间流量巨大（高并发）。但是商品的数量有限，那么对于秒杀服务来说，只有有限的请求是有效的，要把大部分请求挡在外面，因为服务器的处理资源是有限的，过多的请求容易导致宕机，用户无法访问的情况出现。

削峰从本质上来说就是更多地延缓用户请求，以及层层过滤用户的访问需求，遵从“最后落地到数据库的请求数要尽量少”的原则。

#### 削峰的方案有哪些
- 消息队列削峰
    用消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。消息队列就像“水库”一样，拦蓄上游的洪水，削减进入下游河道的洪峰流量，从而达到减免洪水灾害的目的。
- 流量削峰漏斗：层层削峰
    对请求进行分层过滤，从而过滤掉一些无效的请求。
    ![](https://upload-images.jianshu.io/upload_images/15069341-4275977ca5551477?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp)

#### 分层过滤的核心思想
通过在不同的层次尽可能地过滤掉无效请求。再通过类似Redis这样的分布式缓存，过滤请求等就是典型的在上游拦截读请求

#### 分层过滤的基本原则
- 对写数据进行基于时间的合理分片，过滤掉过期的失效请求
- 对写请求做限流保护，将超出系统承载能力的请求过滤掉
- 对写数据进行强一致性校验，只保留最后有效的数据
- 最终，让“漏斗”最末端（数据库）的才是有效请求。例如：当用户真实达到订单和支付的流程，这个是需要数据强一致性的

#### 什么是限流
限流是指对大流量进行控制，因为业务应用系统的负载能力有限，过多的，非预期的请求对系统压力过大会拖垮业务应用系统。

保障服务稳定的三大利器：熔断降级、服务限流和故障模拟。

#### 常用的限流策略
- Nginx 前端限流
    按照一定的规则如帐号、IP、系统调用逻辑等在 Nginx 层面做限流。
- 业务应用系统限流
    客户端限流和服务端限流
- 数据库限流
    红线区，力保数据库

#### 常用的限流算法
常见的限流算法有：计数器、令牌桶、漏桶。
- 计数器算法
    采用计数器实现限流有点简单粗暴，一般我们会限制一秒钟的能够通过的请求数，比如限流 qps 为 100，算法的实现思路就是从第一个请求进来开始计时，在接下去的 1s 内，每来一个请求，就把计数加 1，如果累加的数字达到了 100，那么后续的请求就会被全部拒绝。等到 1s 结束后，把计数恢复成 0，重新开始计数。

    这种实现方式，相信大家都知道有一个弊端：如果我在单位时间 1s 内的前 10ms，已经通过了 100 个请求，那后面的 990ms，只能眼巴巴的把请求拒绝，我们把这种现象称为“突刺现象”。
- 漏桶算法
    为了消除"突刺现象"，可以采用漏桶算法实现限流，漏桶算法这个名字就很形象，算法内部有一个容器，类似生活用到的漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。

    这种算法，在使用过后也存在弊端：无法应对短时间的突发流量。
- 令牌桶算法
    从某种意义上讲，令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。

    实现思路：可以准备一个队列，用来保存令牌，另外通过一个线程池定期生成令牌放到队列中，每来一个请求，就从队列中获取一个令牌，并继续执行。

    ![](https://img-blog.csdn.net/20170406214327337?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHNibHNi/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

#### 分布式限流 
