---
title: Chapter 9.3 InnoDB 行锁

categories:
- MySQL 性能调优

date: 2020-04-28 00:00:93
---

## 行锁介绍
行锁是偏向 InnoDB 存储引擎，开销大，加锁慢，会出现死锁，锁的粒度最小，发生锁冲突的概率最低，并发度也最高。

InnoDB 与 MyISAM 的两个最大不同点是：一支持事务，而采用了行锁。

## 背景知识

#### 事务及其 ACID 属性
事务是由一组 SQL 语句组成的逻辑处理单元。

事务具有以下 4 个特性，简称为事务的 ACID 属性。

|ACID 属性|含义|
| :-- |
|原子性|事务是一个原子操作，其对数据的修改，要么全部成功，要么全部失败|
|一致性|在事务开始和完成时，数据都必须保持一致状态|
|隔离性|数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境运行|
|持久性|事务完成之后，对于数据的修改是永久性的|

#### 并发事务处理带来的问题

|问题|含义|
|丢失更新|当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖|
|脏独|当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问了这个数据，然后使用了数据|
|不可重复读|一个事务在读取某些数据时，再次读取以前读过的数据，却发现和以前读出的数据不一致|
|幻读|一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其它事务插入了满足其查询条件的新数据|

#### 事务的隔离级别
为了解决上诉提到的事务并发问题，数据库提供了一定的事务隔离机制来解决这个问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使用事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。

数据库的隔离级别有 4 个，由低到高依次为读未提交、读已提交、可重复读、串行化，这四个级别解决了脏写、脏读、不可重复读、幻读这几类问题。

|隔离级别|丢失更新|脏读|不可重复读|幻读|
| :-- |
|Read uncommited|x|y|y|y|
|Read commited|x|x|y|y|
|Repeatable read|x|x|x|y|
|Serializable|x|x|x|x|

MySQL 的数据库的默认隔离级别为 Repeatable read，查看方式为：

```sql
sho variables tx_Isolation;
```

## InnoDB 的行锁模式

## 案例准备工作

## 行锁基本演示

## 行锁升级为表锁
如果不通过索引条件检索数据， 那么 InnoDB 将对表中所有记录都加锁，实际效果和表锁是一样的。

> 如果一个 VARCHAR 类型的索引列（如用户名）没有加单引号（where name = 900 & where name = '900'），则索引失效。

## 间隙锁危害
当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排它锁，InnoDB 会给符合条件的已有数据进行加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。

## InnoDB 行锁争用情况
```sql
show status like 'innodb_row_lock%'
```

## 总结
InnoDB 存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能耗损可能会比表锁更高一点，但是在整体并发处理能力方面要远远高于 MyISAM 的表锁。当系统并发量较高时，InnoDB 的整体性能和 MyISAM 相比就会有比较明显的优势。

但是，InnoDB 的行级锁同样也有其脆弱的一面，当我们使用不当时，可能会让 InnoDB 的整体性能表现不仅不能比 MyISAM 高，甚至可能会更差。

优化建议：
1. 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁
1. 合理设计索引，尽量缩小锁的范围
1. 尽可能检索索引条件，及索引范围，避免间隙锁
1. 尽量可能事务大小，减少锁定资源量和时间长度
1. 尽可能使用低级别事务隔离（但是需要满足业务层面需求）