---
title: Chapter 9.1 锁

categories:
- MySQL 性能调优

date: 2020-04-28 00:00:91
---
只有正确指定主键，才会执行行锁，否则执行表锁。

无锁
```sql
select * from user where id = -1 for update;
```

行锁
```sql
select * from user where id = 1 fro update;

select * from user where id = 1 and name = 'kkk' for update;
```

表锁
```sql
-- 主键不明确
select * from user where name = 'kkk' for update;
select * from user where id <> 3 for update;
```

## 锁算法
#### 行锁算法
Record Lock（普通行锁）
1. 键值在条件范围内
1. 记录存在

Gap Lock（间隙锁）
1. 对于键值不存条件范围内，叫做“间隙”（GAP），引擎会对这个“间隙”加锁，这种机制叫做GAP机制。

Next-Key Lock（行 & 间隙）
1. 在键值范围条件内，同时键值又不存在条件范围内
    ```sql
    -- id 只有 50
    select * from user where id > 49 for update;
    ```

#### 表锁算法
意向锁（升级机制）
1. 当一个事务带着表锁去访问一个被加了行锁的资源，那么此时这个行锁就会升级为意向锁，将表锁定。
    ```sql
    -- 事务 A 升级表锁
    select * from user where id = 10 for update;

    -- 事务 B 锁表
    select * from user where name like 'kkk%' for update;
    ```
自增锁
1. 事务插入自增类型的列时，获取自增锁
    如果一个事务正在往表插入自增记录，其它事务都必须等待

## 实现
共享锁 & 排它锁

> 行锁和表锁其实是粒度的概念，共享锁和排它锁是它们的具体实现

共享锁
1. 允许一个事务去度一行，阻止其它事务去获取该行的排它锁
1. 一般理解：能度，不能写

排它锁：写锁
1. 允许持有排它锁的事务读取数据，阻止其它事务获取该资源的共享锁和排它锁
1. 不能访问任何锁，不代表不能读

注意点
1. 某个事务获取数据的排它锁，其它事务不能获取该数据的任何锁，并不代表其它事务不能无锁读取该数据
    ```sql
    -- 无锁
    select ... from ....

    -- 共享锁
    -- MySQL 8.0 以上，for share 代替了 lock in share mode
    select ... lock in share mode

    -- 排它锁
    update ...
    delete ...
    insert ...
    select ... for update
    ```
## 乐观锁 & 悲观锁
> 不管什么锁都需要加失败重试

乐观锁
1. 一般通过版本号进行更新
    ```sql
    upate user set name = 'www' where id = 1 and version = 1;
    ```
悲观锁

## 原理

## 什么是锁
锁是计算机协调多个进程或线程并发访问同一资源的机制（避免资源争抢）。

加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。

## 锁分类
从对数据操作的粒度分：
1. 表锁：操作时，会锁定整个表
1. 行锁：操作时，会锁定当前操作行

从对数据操作的类型分：
1. 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会相互影响。
1. 写锁（排它锁）：当前操作没有完成之前，它会阻断其它写锁和读锁。

## MySQL锁
相对其它数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。下表中罗列了各种存储引擎对锁的支持情况：

|存储引擎|表级锁|行级锁|页面锁|
| :-- |
|MyISAM|支持|不支持|不支持|
|InnoDB|支持|支持|不支持|
|MEMORY|支持|不支持|不支持|
|DBD|支持|不支持|支持|

MySQL 这 3 种锁的特性可大致归纳如下：

|锁类型|特点|
| :-- |
|表级锁|偏向 MyISAM 存储引擎，开销小；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最小|
|行级锁|偏向 InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高|
|页面锁|开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁直接，并发度一般|

从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更适合！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如 Web 应用。而行锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（OLTP）系统。

## MyISAM 表锁
MyISAM 存储引擎只支持表锁，这也是 MySQL 开始几个版本中唯一支持的锁类型。

#### 如何加锁
MyISAM 在开始执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（INSERT、UPDATE、DELETE 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令 MyISAM 表显式加锁。

显式加表锁语法：
```sql
-- 加读锁
lock table table_name read;

-- 加写锁
lock table table_name write;
```

```sql
-- book 表 user表

-- 客户端1，加book读锁
lock table book read;

-- 客户端1，能正常读book数据
select * from book;

-- 客户端2，能正常读book数据（读锁，共享锁）
select * from book;

-- 客户端1，不能读user数据，因为已经锁定了book，不能访问其它表
select * from user;

-- 客户端2，能读user数据，因为没有锁
select * from user;

-- 客户端1，不能写book数据，因为是读锁
update book set name = 'Solr';

-- 客户端2，写book数据进入阻塞状态，需要客户端1释放表锁才能继续进行
update book set name = 'Solr';
```

理解：
1. 表的读锁和写锁同时只能有一个。一个客户端同一时间只能拥有一个锁。
1. 当一个客户端拥有了一个表的读锁时，只能拥有此表的读权限，不能修改，不能操作其它表。
1. 其它客户端可以共享此锁（不拥有此锁），可以访问此表数据，也可以操作其它表数据。
1. 一个客户端同一时间只能拥有一个锁。所以其它客户端要修改此表，只能等待锁释放了。

test:
1. 当一个线程拥有了一个表的读锁，它不会阻塞其它线程的读操作，会阻塞写操作。

## 结论
锁模式的相互兼容性：

|当前锁模式|无请求|读请求锁|写请求锁|
| :-- |
|读锁|是|是|否|
|写锁|是|否|否|

由上表可见：
1. 对 MyISAM 表的读操作，不会阻塞其它用户对同一表的读请求，但会阻塞对同一表的写请求。
1. 对 MyISAM 表的写操作，则会阻止其它用户对同一表的读和写操作。

此外，MyISAM 的读写锁调度是写优先，这也是 MyISAM 不适合做写为主的表的存储引擎的原因。因为写锁后，其它线程不能做任何操作，大量的更新会使得查询很难得到锁，从而造成永远阻塞。

## 锁的操作
```sql
-- 查询锁的争用情况
show open tables;

-- 查询表的锁定情况
show status like 'Table_lo%'
```