---
title: Chapter 5.2 索引的原理

categories:
- MySQL 性能调优

date: 2020-04-28 00:00:52

mathjax: true
---

## 为什么要用索引，以及索引的原理
首先我们看下在没有索引的情况下是怎么查找数据的：

## 为什么要用B+树


## 最左前缀原则


其实建索引的原理就是将磁盘I/O操作的最小化，不在磁盘中排序，而是在内存中排好序，通过排序的规则去指定磁盘读取就行，也不需要在磁盘上随机读取。


当一个表中有100万数据，而经常用到的数据只有40万或40万以下，是不用考虑建立索引的，没什么性能提升。


使用count统计数据量的时候建议使用count(*)而不是count(列)，因为count(*)MySQL是做了优化的。

什么时候开MySQL的查询缓存，交易系统（写多、读少）、SQL优化测试，建议关闭查询缓存，论坛文章类系统（写少、读多），建议开启查询缓存。

21. 复杂SQL语句优化的思路：



1）首先考虑在一个表中能不能取到有关的信息，尽量少关联表
2）关联条件争取都走主键或外键查询条件，能走到对应的索引
3）争取在满足业务上走小集合数据查找
4）INNER JOIN 和子查询哪个更快，场景不一致速度也不同

where条件多条件一定要按照小结果集排大结果集前面

## 索引的原理
索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小节，然后找到页数。相似的例子还有：查字典，查火车车次，飞机航班等

> 本质都是：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。

## 索引的数据结构
#### 树
树状图是一种数据结构，它是由 n（n >= 1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

它具有以下的特点：
1. 每个结点有零个或多个子结点

1. 没有父结点的结点称为根结点

1. 每一个非根结点有且只有一个父结点

1. 除了根结点外，每个子结点可以分为多个不相交的子树

在下图中：
1. 根节点：A

1. 父节点：A 是 B、C 的父节点

1. 叶子节点：D、E 是叶子节点

1. 深度：树的深度/高度是 3

![](https://img2018.cnblogs.com/blog/827651/201812/827651-20181217164400401-478241633.png)

#### B+ 树
B+ 树是通过二叉查找树，再由平衡二叉树，B 树演化而来。

![](https://img2018.cnblogs.com/blog/827651/201812/827651-20181220151345766-1557776352.png)

B+ 树性质
1. 索引字段要尽量的小
    通过上面的分析，我们知道 I/O 次数取决于 B+ 树的高度 $h$，假设当前数据表的数据为 $n$，每个磁盘块的数据项的数量是 $m$，则有 $h=㏒_(m+1)n$，当数据量 $n$ 一定的情况下，$m$ 越大，$h$ 越小；而 $m = \frac {磁盘块的大小}{数据项的大小}$，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如 **int** 占 4 字节，要比 **bigint** 8 字节少一半。这也是为什么 B+ 树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于 1 时将会退化成线性表。

1. 索引的最左匹配特性
    当 B+ 树的数据项是复合的数据结构，比如（**name**, **age**, **sex**）的时候，B+ 数是按照从左到右的顺序来建立搜索树的。当（**张三**, **20**, **F**）这样的数据来检索的时候，B+ 树会优先比较 **name** 来确定下一步的所搜方向，如果 **name** 相同再依次比较 **age** 和 **sex**，最后得到检索的数据；但当（**20**,**F**）这样的没有 **name** 的数据来的时候，B+ 树就不知道下一步该查哪个节点，因为建立搜索树的时候 **name** 就是第一个比较因子，必须要先根据 **name** 来搜索才能知道下一步去哪里查询。比如当（**张三**,**F**）这样的数据来检索时，B+ 树可以用 **name** 来指定搜索方向，但下一个字段 **age** 的缺失，所以只能把名字等于**张三**的数据都找到，然后再匹配性别是 **F** 的数据了， 这个是非常重要的性质，即索引的最左匹配特性。把名字等于**张三**的数据都找到，然后再匹配性别是 **F** 的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

## 聚合索引与辅助索引
在数据库中，B+ 树的高度一般都在 2~4 层，这也就是说查找某一个键值的行记录时最多只需要 2 到 4 次 IO，这倒不错。因为当前一般的机械硬盘每秒至少可以做 100 次 IO，2~4 次的 IO 意味着查询时间只需要 0.02~0.04 秒。

数据库中的 B+ 树索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。

聚集索引与辅助索引相同的是：不管是聚集索引还是辅助索引，其内部都是 B+ 树的形式，即高度是平衡的，叶子结点存放着所有的数据。

聚集索引与辅助索引不同的是：叶子结点存放的是否是一整行的信息。

#### 聚集索引
InnoDB 存储引擎表是索引组织表，即表中数据按照主键顺序存放。

而聚集索引就是按照每张表的主键构造一棵 B+ 树，同时叶子结点存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。

聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同 B+ 树数据结构一样，每个数据页都通过一个双向链表来进行链接。

如果未定义主键，MySQL 取第一个唯一索引而且只含非空列作为主键，InnoDB 使用它作为聚簇索引。如果没有这样的列，InnoDB 就自己产生一个这样的 Id 值，它有六个字节，而且是隐藏的，使其作为聚簇索引。

由于实际的数据页只能按照一棵 B+ 树进行排序，因此每张表只能拥有一个聚集索引。在多数情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。此外由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值得查询。

聚集索引的好处之一：它对主键的排序查找和范围查找速度非常快，叶子节点的数据就是用户所要查询的数据。如用户需要查找一张表，查询最后的 10 位用户信息，由于 B+ 树索引是双向链表，所以用户可以快速找到最后一个数据页，并取出 10 条记录。

聚集索引的好处之二：范围查询（range query），即如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可。

#### 辅助索引
表中除了聚集索引外其他索引都是辅助索引（Secondary Index，也称为非聚集索引），与聚集索引的区别是：辅助索引的叶子节点不包含行记录的全部数据。

叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含一个书签（bookmark）。该书签用来告诉 InnoDB 存储引擎去哪里可以找到与索引相对应的行数据。

由于 InnoDB 存储引擎是索引组织表，因此 InnoDB 存储引擎的辅助索引的书签就是相应行数据的聚集索引键。

辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引，但只能有一个聚集索引。当通过辅助索引来寻找数据时，InnoDB 存储引擎会遍历辅助索引并通过叶子级别的指针获得只想主键索引的主键，然后再通过主键索引来找到一个完整的行记录。

举例来说，如果在一棵高度为 3 的辅助索引树种查找数据，那需要对这个辅助索引树遍历 3 次找到指定主键，如果聚集索引树的高度同样为 3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在的页，因此一共需要 6 次逻辑 IO 访问才能得到最终的一个数据页。

## 索引算法
我们可以在创建上述索引的时候，为其指定索引类型，分两类
- Hash：查询单条快，范围查询慢
- BTree：B+ 树，层数越多，数据量指数级增长（默认）


## 索引命中
并不是说我们创建了索引就一定会加快查询速度，若想利用索引达到预想的提高查询速度的效果，我们在添加索引时，必须遵循以下问题：
1. 范围问题，或者说条件不明确

1. 

## 联合索引和覆盖索引
#### 联合索引
联合索引是指对表上的多个列合起来做一个索引。联合索引的创建方法与单个索引的创建方法一样，不同之处仅在于有多个索引列。

那么何时需要使用联合索引呢？在讨论这个问题之前，先来看一下联合索引内部的结果。从本质上来说，联合索引就是一棵 B+ 树，不同的是联合索引的键值得数量不是 1，而是 >=2。接着来讨论两个整型列组成的联合索引，假定两个键值得名称分别为 a、b 如图：

![](https://images2018.cnblogs.com/blog/1036857/201711/1036857-20171126004856453-1491949427.png)

可以看到这与我们之前看到的单个键的 B+ 树并没有什么不同，键值都是排序的，通过叶子结点可以逻辑上顺序地读出所有数据，就上面的例子来说，即（1,1），（1,2），（2,1），（2,4），（3,1），（3,2），数据按（a,b）的顺序进行了存放。

因此，对于查询
```sql
select * from table where a = xxx and b = xxx
```

显然是可以使用 (a, b) 这个联合索引的，而对于单个列 a 的查询

```sql
select * from table where a = xxx
```

也是可以使用（a, b）这个索引的。

但对于 b 列的查询
```sql
select * from table where b = xxx,
```
则不可以使用（a,b） 索引，其实你不难发现原因，叶子节点上b的值为 1、2、1、4、1、2 显然不是排序的，因此对于 b 列的查询使用不到 (a,b) 索引。

联合索引的第二个好处是在第一个键相同的情况下，已经对第二个键进行了排序处理，例如在很多情况下应用程序都需要查询某个用户的购物情况，并按照时间进行排序，最后取出最近三次的购买记录，这时使用联合索引可以帮我们避免多一次的排序操作，因为索引本身在叶子节点已经排序了。

#### 覆盖索引
InnoDB 存储引擎支持覆盖索引（covering index，或称索引覆盖），即从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。

使用覆盖索引的一个好处是：辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的 IO 操作。

> 注意：覆盖索引技术最早是在 InnoDB Plugin 中完成并实现，这意味着对于 InnoD B版本小于 1.0 的，或者 MySQL 数据库版本为 5.0 以下的，InnoDB 存储引擎不支持覆盖索引特性。



