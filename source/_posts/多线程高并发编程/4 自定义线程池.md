---
title: 4 自定义线程池

categories:
- 多线程高并发编程

tags:
- Thread
- ThreadPoolExcutor

date: 2020-02-03
---

## Executors存在什么问题
在阿里巴巴Java开发者手册中指明，使用Executor创建线程可能会导致OOM（OutOfMemory）：
1. `FixedThreadPool和SingleThreadPool`
    允许的请求队列长度为Integer.MAX_VALUE，可能会积累大量的请求，从而导致OOM
1. `CacheThreadPool和ScheuledThreadPool`
    允许的创建线程数为Integer.MAX_VALUE，可能会积累大量的请求，从而导致OOM

```java
ExecutorService service = Executors.newFixedThreadPool(15);
for (int i = 0; i < Integer.MAX_VALUE; i++) {
    service.execute(() -> {
        // doing something
    });
}

```

通过指定JVM参数`-Xmx8m -Xms8m`运行以上代码，会抛出OOM`java.lang.OutOfMemoryError: GC overhead limit exceeded`。

## 创建线程池的正确姿势
避免使用Executor创建线程，主要是避免使用其中的默认实现。那么我们可以自己直接调用`ThreadPoolExecutor`的构造函数来自己创建线程池。在创建的同时，给`BlockQueue`指定容量就可以了。

```java
ExecutorService service = new ThreadPoolExecutor(10, 10, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue(10));
```

这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出`java.util.concurrent.RejectedExecutionException`，这是因为当前线程池使用的队列是有边界队列，队列已满了便无法继续处理新的请求。但是异常总比发生错误要好。

除了自己定义`ThreadPoolExecutor`外，还可以使用如apache和guava等开源类库。

```java
public class GuavaExecutorsDemo {
    private static ThreadFactory nameThreadFactory = new ThreadFactoryBuilder().setNameformat("demo-pool-%d").build();

    private static ExecutorService pool = new ThreadPoolExecutor(5, 200, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(1024), nameThreadFactory, new ThreadPoolExecutor.AbortPolicy());

    public static void main(String[] args) {
        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            pool.execute(new SubThread());
        }
    }
}

通过上述方式创建线程时，不仅可以避免OOM的问题，还可以自定义线程名称，更加方便的出错的时候溯源。
```