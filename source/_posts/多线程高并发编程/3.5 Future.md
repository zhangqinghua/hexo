---
title: 2.1 火车售票问题

categories:
- 多线程高并发编程

tags:
- thread

date: 2020-01-22
---
有N张火车票，每张票都有一个编号，同时有10个窗口对外售票。请写一个模拟程序。

## 实现一
```java
private static List<String> tickets = new ArrayList<>();

static {
    for (int i = 0; i < 10000; i++) {
        tickets.add("票编号：" + i);
    }
}

public static void main(String[] args) {
    for (int i = 0; i < 10; i++) {
        new Thread(() -> {
            while (tickets.size() > 0) {
                // 售卖操作
                TimeUnit.SECONEDS.sleep(10);
                System.out.println("销售了--" + tickets.remove(0));
            }
        }).start();
    }
}
```

这里程序有2个问题：
1. 判断数量和售卖不是原子性的，有可能超票
1. 售卖`remove`也不是原子性的，有可能卖重

## 实现二
```java
private static Vector<String> tickets = new Vector<>();

static {
    for (int i = 0; i < 10000; i++) {
        tickets.add("票编号：" + i);
    }
}

public static void main(String[] args) {
    for (int i = 0; i < 10; i++) {
        new Thread(() -> {
            while (tickets.size() > 0) {
                // 售卖操作
                TimeUnit.SECONEDS.sleep(10);
                System.out.println("销售了--" + tickets.remove(0));
            }
        }).start();
    }
}
```

这里使用了`Vetor`容器，它是线程安全的，解决了售卖`remove`的原子性问题，但是判断数量和售卖依然是分离的。

## 实现三
```java
private static List<String> tickets = new ArrayList<>();

static {
    for (int i = 0; i < 10000; i++) {
        tickets.add("票编号：" + i);
    }
}

public static void main(String[] args) {
    for (int i = 0; i < 10; i++) {
        new Thread(() -> {
            while (true) {
                synchronized (tickets) {

                    if (tickets.size() <= 0) break;
                    // 售卖操作
                    TimeUnit.SECONEDS.sleep(10);
                    System.out.println("销售了--" + tickets.remove(0));
                }
            }
        }).start();
    }
}
```

这里使用了同步锁`synchronized`，解决了超卖和重卖的问题，但每次只能有一个售票的操作，影响了性能。

## 实现四
```java
private Queue<String> tickets = new ConcurrentLinkedQueue<>();

static {
    for (int i = 0; i < 10000; i++) {
        tickets.add("票编号：" + i);
    }
}

public static void main(String[] args) {
    for (int i = 0; i < 10; i++) {
        new Thread(() -> {
            while (true) {
                String s = tickets.poll();
                if (s == null) break;
                // 售卖操作
                TimeUnit.SECONEDS.sleep(10);
                System.out.println("销售了--" + s);
            }
        }).start();
    }
}
```

这里使用了`ConcurrentLinkedQueue`，一个基于链接节点的无界线程安全队列。此队列按照先进先出的原则对元素进行排序。`ConcurrentLinkedQueue`是支持并发操作的，所以效率相当高，也没有超卖和重卖的问题。
