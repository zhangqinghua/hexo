---
title: Java 虚拟机

categories: 
- Java

tags:
- Java
- 虚拟机

date: 2018-12-10
---

学习 Java 虚拟机能深入地理解 Java 这门语言。对于刚刚工作一两年的朋友来说，各个 API 都没用熟，自然不会去深入研究 Java 中的各种细节。但对于工作了三年以后的朋友来说，很多时候你要解决一个问题必须深入到字节码层次去分析，你才能得到准确的结论，而字节码就是虚拟机的一部分。

学习虚拟机是为线上排查问题打下基础。我们知道我们一个 Java 应用部署在线上机器上，肯定时不时会出现问题。除去网络、系统本身问题，很多时候 Java 应用出现问题，就是 Java 虚拟机的内存出现了问题。要么是内存溢出了，要么是 GC 频繁导致响应慢等等。

<!-- more -->


## Java 语言的前世今生
Java 语言是一门存在了 20 多年的语言，其年纪比我自己还大。虽然存在了这么长时间，但 Java 至今都是最大的工业级语言，许多大型互联网公司均采用 Java 来实现其业务系统。大到国际电商巨头阿里巴巴，小到无名小公司，我们均可看到 Java 的身影。

### Java 语言的历史
1. 在 1991 年，James Gosling 博士发布了 Oak，这个是 Java 语言的前身。但一直到 1995 年的时候，Oak 语言才改名为 Java。
1. 1991 年，James Gosling 博士发布产品 Oak，这是 Java 语言的前身。
1. 1995 年，Oak 语言改名为 Java。
1. 1996 年，JDK1.0 发布，提供了纯解释执行的 Java 虚拟机实现：Sun Classic VM。
1. 1997 年，JDK1.1 发布，代表技术有：JDBC、JavaBeans、内部类、反射。
1. 1998 年，JDK1.2 发布，Java 技术体系被拆分为 J2SE、J2EE、J2ME 三大体系。
1. 2000 年，JDK1.3 发布，默认的 Java 虚拟机由 Sun Classic VM 改为 HotSopt。
1. 2002 年，JDK1.4 发布，Java 真正走向成熟，代表技术有：正则表达式、NIO等。
1. 2004 年，JDK1.5 发布，对语法易用性做了很大改进，新增了泛型、枚举等，代表技术有：并发包等。
1. 2006 年，JDK1.6 发布，将 J2EE/J2SE/J2ME 的命名方式改为 Java SE 6、Java EE 6、Java ME 6。
1. 2009 年，Sun 公司因为经营不善被 Oracle 公司收购。
1. 2011 年，JDK1.7 发布。
1. 2013 年，JDK1.8 发布。

从上面的历史我们可以知道 Java 语言具有众多的特性，但是其众多特性并不是一蹴而就的，而是一点点迭代而来的。JDK 每个版本新增的语言特性如下：

1. 1997 年，JDK1.1 发布，新增了JDBC、JavaBeans、内部类、反射。
1. 2002 年，JDK1.4 发布，新增了正则表达式、NIO等。
1. 2004 年，JDK1.5 发布，新增了泛型、枚举、并发包等。

### JRE 与 JDK
JRE仅包含运行 Java 程序的必需组件，包括 Java 虚拟机以及 Java 核心类库等。

JDK除了包含 JRE外，还附带了一系列开发、诊断工具。

### JDK 与 J2SE
JDK 是一个核心库、开发工具、诊断工具的合集，而 Java SE 则是一个技术体系。

### J2SE 与 Java SE
J2SE 称之为标准版技术体系（Java 2 Standard Edition），它包含了构成 Java 语言核心的类，例如：数据库连接、网络编程、接口定义等。J2SE 技术体系主要用于桌面应用软件的编程。正因为 J2SE 包含了 JDK 核心类，所以在我们下载 JDK 时，你会看到其实下载处的文字说明是「Java SE 11.0.1 is the latest release for JDK 11」。

J2EE 称之为企业版技术体系（Java 2 Enterprise Edition），它除了包含 J2SE 中的类，还包含用于开发企业级应用的类，比如：Servlet、JSP、EJB 等。J2EE 技术体系主要用于分布式的网络程序的开发，如电子商务网站等。

J2ME 称之为嵌入式技术体系（Java 2 Micro Edition），它包含 J2SE 中的一部分类。J2ME 技术体系主要用于消费类电子产品的软件开发，例如：手机、PDA、寻呼机等。 


## 虚拟机的历史
说起 Java 虚拟机，许多人就会将其与 HotSpot 虚拟机等同看待。但实际上 Java 虚拟机除了 HotSpot 之外，还有 Sun Classic VM、Exact VM、BEA JRocketit、IBM J9 等等。今天我们就来简单回顾下 Java 虚拟机的发展历史。

### 虚拟机始祖：Sun Classic
在 1996 年 1 月 23 日，Sun 发布 JDK 1.0，其中自带的虚拟机就是 Classic VM。但这款虚拟机有个特点，即只能使用纯解释器的方式来执行 Java 代码，如果要使用 JIT 编译器那就必须使用外挂。

tips: 执行代码可以分为编译执行和解释执行。解释执行指的是边解释边运行代码。编译执行指的是先编译，后执行。

但如果外挂了 JIT 编译器，那么 JIT 编译器就完全替代了虚拟机的执行系统，解释器便不再工作了。简单地说，在 Sun Classic 虚拟机中，解释器与编译器无法共同存在。

而且即使使用了外挂 JIT 编译器，Sun Classic 虚拟机的执行速度也快不起来。因为解释器无法和编译器配合工作，虚拟机无法判断哪个方法是使用频率高，所以它只能对每个方法都进行编译。这就导致了虚拟机只能采取相对简单的优化技术，无法进行耗时稍微较高的优化技术。因为如果对所有代码都采用耗时高的优化技术，那么编译时间会慢得无法接受。

虽然 Sun Classic 虚拟机有这样那样的问题，但其生命力还是非常旺盛的。在 JDK 1.3 之前，其一直是 JDK 的默认虚拟机。而在 JDK 1.3 时，HotSpot 成为默认虚拟机，其作为备用虚拟机存在。到了 JDK 1.4 时，其正式退出历史舞台。可以说 Sun Classic 还是存在了将近四年的时间，但另外一个虚拟机可就没有那么好的运气了。

### 无疾而终：Sun Exact VM
在 Sun Classic 发布后，Sun 的虚拟机团队在 JDK 1.2 时 发布了一款名为 Exact VM 的虚拟机，尝试解决 Classic VM 遇到的所有问题。它的执行系统解决了 Classic VM 存在的解释器和编译器无法同时工作的问题，还具备了一些现代高性能处理器的特性，如：两级即时编译等。

除此之外，Exact VM 还改进了虚拟机的对象查找方式。在 Classic VM 中，如果要查找一个对象，那么需要通过句柄（类似指针）来查找。如果需要查找一个对象，那么需要通过其构建成的句柄树一层层寻找。但在 Exact VM 中使用了准确式内存管理（Exact Memory Management），即虚拟机可以知道内存中某个位置的数据具体是什么类型，这样就减少了查找的的开销，提升执行性能。

但可惜的是，虽然 ExactVM 发布了，但一直到它退出时，其都没有真正被大规模使用过。在 JDK 1.2 其发布时，Exact VM 推出，但Sun Classic VM 依然作为默认的 Java 虚拟机。在 JDK 1.3 发布时，推出虚拟机 HotSpot VM 作为默认虚拟机，而 Sun Classic VM 作为备用虚拟机。

### 武林盟主：Sun HotSpot VM
HotSpot VM 可以说是使用最为广泛的 Java 虚拟机，几乎所有的 Java 虚拟机都知道它。但实际上，这个虚拟机并不是由 Sun 公司原生开发的，而是由一个叫 Longview Technologies 公司开发的。而 Sun 公司注意到了这款虚拟机在 JIT 编译上的许多优秀成果，于 1997 年收购了 Longview Technologies 公司，从而获得了 HotSpot VM。

要说 HotSpot 不仅仅有前面说到两款虚拟机的优点（如：准确式内存管理），也有许多自己的新技术，例如：热点探测技术。热点探测技术指的是通过执行计数器找出最具优化价值的代码，然后通知 JIT 编译器以方法为单位进行深度优化编译。但其实 Exact VM 中也有类似的技术，Sun 公司内部还因此大吵了一架，但最终还是选择了 HotSpot 作为默认的虚拟机，其中的缘由不得而知。

总的来说，从 2000 年 JDK 1.3 发布，HotSpot VM 作为默认的虚拟机开始登上历史舞台。到现在 2018 年，18 年时间过去了，其依然是我们最常用的虚拟机，可见 Sun HotSpot VM 的生命力之顽强。

### 百家争鸣：BEA JRockit / IBM J9 VM
前面说的都是 Sun 公司推出的虚拟机，但除了 Sun 公司之外，其他组织、公司也研发过不少的虚拟机实现，其中最著名的要算 BEA 公司的 BEA JRockit 和 IBM 公司的 J9 VM 了。

BEA 公司的 JRockit 是一款专注于服务器硬件和服务端应用场景的虚拟机，其针对服务端场景做了大量的优化，因此其不太关注程序启动速度。JRockit 虚拟机内部不包含解释器实现，全部代码都靠即时编译器编译后执行。此外，其提供的 MissionControl 服务套件也十分强大。

IBM 公司的 J9 VM 则是一款比较通用的虚拟机，其定位应用于从服务端到桌面应用再到嵌入式的多用途虚拟机。IBM 公司开发 J9 VM 的目的是将其作为 IBM 公司各种 Java 产品的执行平台。

### 武林外传：那些无名虚拟机
从 Sun Classic、Sun Exact VM、Sun HotSpot VM，再到 BEA JRockit、IBM J9 VM，这几个虚拟机可以说是虚拟机的正史了，是每个 Java 程序员应该了解的。但在这之外，其实还有各种各样的虚拟机存在。

例如性能最强悍的并不是上面所说的虚拟机，而是名为 Azul VM 和 BEA Liquid VM 的专用商业及虚拟机。这些虚拟机只运行在特定硬件平台，因此要求比较高。但其性能也是非常强悍的。其可以管理至少数十个 CPU 和数百 GB 的内存资源，还提供在巨大内存范围内实现可控 GC 时间的垃圾收集器等等。

此外还有许许多多其他的虚拟机存在，例如：Apache Harmony、Google Android Dalvik VM、Mircosoft JVM 等等。

### 最后的赢家：Oracle
看了这么些历史，似乎都是在说 Sun公司发布的虚拟机，与 Oracle 似乎没有什么关系。但在 2010 年，Oracle 公司收购了 Sun 公司，这样 Oracle 就拥有了 HotSpot VM。再加上其在 2008 年收购 BEA 公司获得的 JRocket VM，Oracle 公司就拥有了地球上最优秀的两款虚拟机。

对于虚拟机未来的规划，Oracle 宣布会将 JRockit 的优秀特性整合到 HotSpot VM 中，例如移植 JRockit 的垃圾回收器和 MissionControl 服务。

### 附录：Java 虚拟机历史
JDK 版本升级不仅仅体现在语言和功能特性上，还包括了其编译和执行的 Java 虚拟机的升级。

1. 1996 年，JDK 1.0 发布时，提供了纯解释执行的 Java 虚拟机实现：Sun Classic VM。
1. 1997 年，JDK 1.1 发布时，虚拟机没有做变更，依然使用 Sun Classic VM 作为默认的虚拟机。
1. 1998 年，JDK 1.2 发布时，提供了运行在 Solaris 平台的 Exact VM 虚拟机，但此时还是用 Sun Classic VM 作为默认的 Java 虚拟机。
1. 2000 年，JDK1.3 发布，默认的 Java 虚拟机由 Sun Classic VM 改为 Sun HotSopt VM，而 Sun Classic VM 则作为备用虚拟机。
1. 2002 年，JDK 1.4 发布，Sun Classic VM 退出商用虚拟机舞台，直接使用 Sun HotSpot VM 作为默认虚拟机一直到现在。


## 到底什么是虚拟机？
我们都知道在 Windows 系统上一个软件包装包是 exe 后缀的，而这个软件包在苹果的 Mac OSX 系统上是无法安装的。类似地，Mac OSX 系统上软件安装包则是 dmg 后缀，同样无法在 Windows 系统上安装。

为什么不同系统上的软件无法安装，这是因为操作系统底层的实现是不一样的。对于 Windows 系统来说，exe 后缀的软件代码最终编译成 Windows 系统能识别的机器码。而 Mac OSX 系统来说，dmg 后缀的软件代码最终编译成 Mac OSX 系统能识别的代码。

系统软件无法通用是一个常见的问题。但使用过 Java 的同学都知道，Java 代码可以在服务端（Linux 系统）运行，也可以在 Windows 系统运行，但我们并没有生成多份不同的代码。所以 Java 语言是如何做到的呢？

与其他语言不同，Java 语言并不直接将代码编译成与系统有关的机器码，而是编译成一种特定的语言规范，这种语言规范我们称之为字节码。无论 Java 程序要在 Windows 系统，还是 Mac OSX 系统，抑或是 Linux 系统，它首先都得编译成字节码文件，之后才能运行。

但即使编译成字节码文件了，各个系统还是无法明白字节码文件的内容，这时候就需要 Java 虚拟机的帮助了。Java 虚拟机会解析字节码文件的内容，并将其翻译为各操作系统能理解的机器码。

![](001.jpg)

简单地说，对于同样一份 Java 源码文件，我们编译成字节码之后，无论是 Linux 系统还是 Windows 系统都不认识。这时候 Java 虚拟机就是一个翻译官，在 Linux 系统上翻译成 Linux 机器码给 Linux 系统听，在 Windows 系统上翻译成 Windows 机器码给 Windows 系统听。这样一来，Java 就实现了「Write Once，Run Anywhere」的伟大愿景了。

在 Java 虚拟机还没出现之前，为了支持软件在不同系统上运行，我们必须在多个平台写多份代码，分别对应特定的系统。但 Java 虚拟机出现之后，你只需要按照特定规范编译书写，编译器编译成字节码文件后，虚拟机会帮你将字节码生成对应的 Windows Code 和 Mac Code。本质上最终还是会生成 Windows Code 和 Mac Code 两份机器代码，但对于开发人员来说，却只需要写一次代码了。Java 虚拟机帮开发人员承担了重复的工作，让开发效率更高了。

很多初学者关于 Java 虚拟机有一个误区，他们会觉得 Java 虚拟机只能运行 Java 代码。但实际上 Java 虚拟机运行的是字节码文件。换句话说，如果你用 php 语言写一段代码，并自己用特定编译器能生成符合字节码规范的字节码文件，那么 Java 虚拟机也是可以运行的。

所以虽然名字是 Java 虚拟机，但 Java 虚拟机与 Java 语言没有直接关系，它只按照 Java 虚拟机规范去读取 Class 文件，并按照规定去解析、执行字节码指令，仅此而已。

如果你够牛逼，你完全可以写一个编译器，将 PHP 语言代码编译成符合 Java 虚拟机规范的字节码文件，那么 Java 虚拟机也是可以执行的。

准确地说，Java 虚拟机与字节码文件（Class文件）绑定。

最后，让我们回顾一下，到底什么是虚拟机？其实 Java 虚拟机就是一个字节码翻译器，它将字节码文件翻译成各个系统对应的机器码，确保字节码文件能在各个系统正确运行。


## 从源代码到机器码，发生了什么？


## 字节码文件结构
Java 虚拟机使用字节码实现了跨平台的愿景，无论什么系统，我们都可以使用 Java 虚拟机解释执行字节码。其中，《Java 虚拟机规范》规定了Java 虚拟机结构、Class 类文件结构、字节码指令等内容。

字节码文件结构时一组以 8 位字节为基础的二进制流，各数据项目严格按照顺利紧凑地排列在 Class 文件之中，中间没用任何分隔符。在字节码结构中，有两种最基本的数据类型来表示字节码文件格式，分别是：无符号数和表。


## Java 虚拟机内存结构
看到这里，我相信大家对于一个 Java 源文件是如何变成字节码文件，以及字节码文件的含义已经非常清楚了。那么接下来就是让 Java 虚拟机运行字节码文件，从而得出我们最终想要的结果了。在这个过程中，Java 虚拟机会加载字节码文件，将其存入 Java 虚拟机的内存空间中，之后进行一系列的初始化动作，最后运行程序得出结果。

那么字节码数据在 Java 虚拟机内存中是如何存放的 ？Java 虚拟机在为类实例或成员变量分配内存是如何分配的 ？要解答上面这些问题，我们首先需要了解一下 Java 虚拟机的内存结构。

其实 Java 虚拟机的内存结构并不是官方的说法，在《Java 虚拟机规范》中用的是「运行时数据区」这个术语。但很多时候这个名词并不是很形象，再加上日积月累的习惯，我们都习惯用虚拟机内存结构这个说法了。

> **运行时数据区**
> Java 虚拟机定义了若干种程序运行时会使用的运行时数据区，其中一些会随着虚拟机创建而启动，随着虚拟机退出而销毁。另外一些则是与线程一一对应，这些与线程对应的数据区域会随着线程开始和结束而销毁。

根据《Java 虚拟机规范》中的说法，Java 虚拟机的内存结构可以分为公有和私有两部分。公有指的是所有线程都共享的部分，指的是 Java 堆、方法区、常量池。私有指的是每个线程的私有数据，包括：PC寄存器、Java 虚拟机栈、本地方法栈。

### Java 堆、方法区、常量池
在 Java 虚拟机中，线程共享部分包括 Java 堆、方法区及常量池。

Java 堆指的是从 JVM 划分出来的一块区域，这块区域专门用于 Java 实例对象的内存分配，几乎所有实例对象都在会这里进行内存的分配。之所以说几乎是因为有特殊情况，有些时候小对象会直接在栈上进行分配，这种现象我们称之为「栈上分配」。这里并不深入介绍，后续有章节会介绍。

方法区指的是存储 Java 类字节码的一块区域，它存储了每一个类的结构信息，例如运行时常量池、字段和方法数据、构造方法等。可以看到常量池其实是存放在方法区中的，但《Java 虚拟机规范》将常量池和方法区放在同一等级上，这点我们知道即可。

方法区在不同版本的虚拟机中有不同的表现形式，例如在 1.7 版本的 HotSpot 虚拟机中，方法区称为永久代（Permanent Space），而在 JDK 1.8 中则称之为 MetaSpace。

说完几个部分的大致作用后，我们来深入说说 Java 堆。

根据对象存活的时间不同，Java 堆还被分成年轻代、老年代两个区域，年轻代还被进一步分成 Eden 区、From Survivor 0、To Survivor 1 区。

![Java 堆](002.png)

当有对象需要分配时，一个对象永远优先被分配在年轻代的 Eden 区中。等到 Eden 区域内存不够时，Java 虚拟机会启动垃圾回收，此时 Eden 区中没用被引用的对象的内存就会被回收，而一些存活时间较长的对象则会进入到老年代。在 JVM 中有一个名为 `-XX:MaxTenturingThreshold` 的参数专门用来设置晋升到年老区所需经历的 GC 次数，即在年轻代的对象经过了指定次数的 GC 后，将在下次 GC 是进入老年代。

这里让我们思考一个问题：为什么 Java 堆要进行这样一个区域划分？

根据我们的经验，虚拟机中必要有存活时间很长的对象，也有存活时间很短的对象，这是一个普遍存在的正态发布规律。如果我们将其混在一起，那么因为存活时间短的对象有很多，势必导致频繁的垃圾回收。而垃圾回收时不得不对所以内存进行扫描，但是其实有一部分对象的存活时间很长，对它们进行扫描完全是浪费时间。因此为了提高垃圾回收效率，分区是理所当然了。

另外一个值得思考的问题是：为什么默认的虚拟机配置，Eden : from : to = 8 : 1 :1 呢？

其实这是根据 IBM 公司大量统计得出的结果。根据 IBM 公司对对象存活时间的统计，他们发现 80% 的对象存活时间都很短。于是他们将 Eden 区设置为年轻代的 80%，这样可以减少内存空间的浪费，提高内存空间利用率。

### PC 寄存器、Java 虚拟机栈、本地方法栈

Java 堆以及方法区是共享的，但是有一部分则是线程私有的。线程私有部分可以分为：PC 寄存器、Java 虚拟机栈、本地方法栈三大部分。

PC 寄存器，指的是保存线程当前正在执行的方法。如果这个方法不是 native 方法，那么 PC  寄存器就保存 Java 虚拟机正在执行的字节码指令地址。如果是 native 方法，那么 PC 寄存器保存的值是 undefined。任意时刻，一条 Java 虚拟机线程只会执行一个方法的代码，而这个被线程执行的方法称为该线程的当前方法，其地址被存在 PC 寄存器中。

Java 虚拟机栈，这个栈与线程同时创建，用来存储栈帧，即存储局部变量与一些过程结果的地方。栈帧存储的数据包括：局部变量表、操作数栈。

当 Java 虚拟机使用其它语言（例如 C 语言）来实现指令集解释器时，也会使用到本地方法栈。如果 Java 虚拟机不支持 native 方法，并且自己也不依赖传统栈的话，可以无需支持本地方法栈。

### 总结
一个 Java 类加载到内存中，Java 类的信息会存储在我们的方法区中。如果创建对象，那么对象数据会存放在 Java 堆中。如果调用方法，就会用到 PC 寄存器、Java 虚拟机栈、本地方法栈等结构。


## JVM 类加载机制
类加载机制就是虚拟机将字节码加载进内存，从而进行解析、运行等整个过程，它大致可以分为七个阶段：**加载**、**验证**、**准备**、**解析**、**初始化**、**使用**、**卸载**。

### 加载

> 加载阶段是指类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是将字节码从各个位置（网络、磁盘）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。


```java
class Grandpa {
    static {
        System.out.println("爷爷在静态代码块");
    }
}

class Father extends Grandpa {
    static {
        System.out.println("爸爸在静态代码块");
    }

    public static int age = 25;

    public Father() {
        System.out.println("我是爸爸~");
    }
}

class Son extends Father {
    static {
        System.out.println("儿子在静态代码块");
    }

    public Son() {
        System.out.println("我是儿子~");
    }
}

public class InitializationDemo {
    public static void main(String[] args) {
        System.out.println("爸爸的岁数:" + Son.age);  //入口
    }
}
```