---
title: Java 虚拟机

categories: 
- Java

tags:
- Java
- 虚拟机

date: 2018-12-10
---

学习 Java 虚拟机能深入地理解 Java 这门语言。对于刚刚工作一两年的朋友来说，各个 API 都没用熟，自然不会去深入研究 Java 中的各种细节。但对于工作了三年以后的朋友来说，很多时候你要解决一个问题必须深入到字节码层次去分析，你才能得到准确的结论，而字节码就是虚拟机的一部分。

学习虚拟机是为线上排查问题打下基础。我们知道我们一个 Java 应用部署在线上机器上，肯定时不时会出现问题。除去网络、系统本身问题，很多时候 Java 应用出现问题，就是 Java 虚拟机的内存出现了问题。要么是内存溢出了，要么是 GC 频繁导致响应慢等等。

<!-- more -->


## Java 语言的前世今生
Java 语言是一门存在了 20 多年的语言，其年纪比我自己还大。虽然存在了这么长时间，但 Java 至今都是最大的工业级语言，许多大型互联网公司均采用 Java 来实现其业务系统。大到国际电商巨头阿里巴巴，小到无名小公司，我们均可看到 Java 的身影。

### Java 语言的历史
1. 在 1991 年，James Gosling 博士发布了 Oak，这个是 Java 语言的前身。但一直到 1995 年的时候，Oak 语言才改名为 Java。
1. 1991 年，James Gosling 博士发布产品 Oak，这是 Java 语言的前身。
1. 1995 年，Oak 语言改名为 Java。
1. 1996 年，JDK1.0 发布，提供了纯解释执行的 Java 虚拟机实现：Sun Classic VM。
1. 1997 年，JDK1.1 发布，代表技术有：JDBC、JavaBeans、内部类、反射。
1. 1998 年，JDK1.2 发布，Java 技术体系被拆分为 J2SE、J2EE、J2ME 三大体系。
1. 2000 年，JDK1.3 发布，默认的 Java 虚拟机由 Sun Classic VM 改为 HotSopt。
1. 2002 年，JDK1.4 发布，Java 真正走向成熟，代表技术有：正则表达式、NIO等。
1. 2004 年，JDK1.5 发布，对语法易用性做了很大改进，新增了泛型、枚举等，代表技术有：并发包等。
1. 2006 年，JDK1.6 发布，将 J2EE/J2SE/J2ME 的命名方式改为 Java SE 6、Java EE 6、Java ME 6。
1. 2009 年，Sun 公司因为经营不善被 Oracle 公司收购。
1. 2011 年，JDK1.7 发布。
1. 2013 年，JDK1.8 发布。

从上面的历史我们可以知道 Java 语言具有众多的特性，但是其众多特性并不是一蹴而就的，而是一点点迭代而来的。JDK 每个版本新增的语言特性如下：

1. 1997 年，JDK1.1 发布，新增了JDBC、JavaBeans、内部类、反射。
1. 2002 年，JDK1.4 发布，新增了正则表达式、NIO等。
1. 2004 年，JDK1.5 发布，新增了泛型、枚举、并发包等。

### JRE 与 JDK
JRE仅包含运行 Java 程序的必需组件，包括 Java 虚拟机以及 Java 核心类库等。

JDK除了包含 JRE外，还附带了一系列开发、诊断工具。

### JDK 与 J2SE
JDK 是一个核心库、开发工具、诊断工具的合集，而 Java SE 则是一个技术体系。

### J2SE 与 Java SE
J2SE 称之为标准版技术体系（Java 2 Standard Edition），它包含了构成 Java 语言核心的类，例如：数据库连接、网络编程、接口定义等。J2SE 技术体系主要用于桌面应用软件的编程。正因为 J2SE 包含了 JDK 核心类，所以在我们下载 JDK 时，你会看到其实下载处的文字说明是「Java SE 11.0.1 is the latest release for JDK 11」。

J2EE 称之为企业版技术体系（Java 2 Enterprise Edition），它除了包含 J2SE 中的类，还包含用于开发企业级应用的类，比如：Servlet、JSP、EJB 等。J2EE 技术体系主要用于分布式的网络程序的开发，如电子商务网站等。

J2ME 称之为嵌入式技术体系（Java 2 Micro Edition），它包含 J2SE 中的一部分类。J2ME 技术体系主要用于消费类电子产品的软件开发，例如：手机、PDA、寻呼机等。 


## 虚拟机的历史
说起 Java 虚拟机，许多人就会将其与 HotSpot 虚拟机等同看待。但实际上 Java 虚拟机除了 HotSpot 之外，还有 Sun Classic VM、Exact VM、BEA JRocketit、IBM J9 等等。今天我们就来简单回顾下 Java 虚拟机的发展历史。

### 虚拟机始祖：Sun Classic
在 1996 年 1 月 23 日，Sun 发布 JDK 1.0，其中自带的虚拟机就是 Classic VM。但这款虚拟机有个特点，即只能使用纯解释器的方式来执行 Java 代码，如果要使用 JIT 编译器那就必须使用外挂。

tips: 执行代码可以分为编译执行和解释执行。解释执行指的是边解释边运行代码。编译执行指的是先编译，后执行。

但如果外挂了 JIT 编译器，那么 JIT 编译器就完全替代了虚拟机的执行系统，解释器便不再工作了。简单地说，在 Sun Classic 虚拟机中，解释器与编译器无法共同存在。

而且即使使用了外挂 JIT 编译器，Sun Classic 虚拟机的执行速度也快不起来。因为解释器无法和编译器配合工作，虚拟机无法判断哪个方法是使用频率高，所以它只能对每个方法都进行编译。这就导致了虚拟机只能采取相对简单的优化技术，无法进行耗时稍微较高的优化技术。因为如果对所有代码都采用耗时高的优化技术，那么编译时间会慢得无法接受。

虽然 Sun Classic 虚拟机有这样那样的问题，但其生命力还是非常旺盛的。在 JDK 1.3 之前，其一直是 JDK 的默认虚拟机。而在 JDK 1.3 时，HotSpot 成为默认虚拟机，其作为备用虚拟机存在。到了 JDK 1.4 时，其正式退出历史舞台。可以说 Sun Classic 还是存在了将近四年的时间，但另外一个虚拟机可就没有那么好的运气了。

### 无疾而终：Sun Exact VM
在 Sun Classic 发布后，Sun 的虚拟机团队在 JDK 1.2 时 发布了一款名为 Exact VM 的虚拟机，尝试解决 Classic VM 遇到的所有问题。它的执行系统解决了 Classic VM 存在的解释器和编译器无法同时工作的问题，还具备了一些现代高性能处理器的特性，如：两级即时编译等。

除此之外，Exact VM 还改进了虚拟机的对象查找方式。在 Classic VM 中，如果要查找一个对象，那么需要通过句柄（类似指针）来查找。如果需要查找一个对象，那么需要通过其构建成的句柄树一层层寻找。但在 Exact VM 中使用了准确式内存管理（Exact Memory Management），即虚拟机可以知道内存中某个位置的数据具体是什么类型，这样就减少了查找的的开销，提升执行性能。

但可惜的是，虽然 ExactVM 发布了，但一直到它退出时，其都没有真正被大规模使用过。在 JDK 1.2 其发布时，Exact VM 推出，但Sun Classic VM 依然作为默认的 Java 虚拟机。在 JDK 1.3 发布时，推出虚拟机 HotSpot VM 作为默认虚拟机，而 Sun Classic VM 作为备用虚拟机。

### 武林盟主：Sun HotSpot VM
HotSpot VM 可以说是使用最为广泛的 Java 虚拟机，几乎所有的 Java 虚拟机都知道它。但实际上，这个虚拟机并不是由 Sun 公司原生开发的，而是由一个叫 Longview Technologies 公司开发的。而 Sun 公司注意到了这款虚拟机在 JIT 编译上的许多优秀成果，于 1997 年收购了 Longview Technologies 公司，从而获得了 HotSpot VM。

要说 HotSpot 不仅仅有前面说到两款虚拟机的优点（如：准确式内存管理），也有许多自己的新技术，例如：热点探测技术。热点探测技术指的是通过执行计数器找出最具优化价值的代码，然后通知 JIT 编译器以方法为单位进行深度优化编译。但其实 Exact VM 中也有类似的技术，Sun 公司内部还因此大吵了一架，但最终还是选择了 HotSpot 作为默认的虚拟机，其中的缘由不得而知。

总的来说，从 2000 年 JDK 1.3 发布，HotSpot VM 作为默认的虚拟机开始登上历史舞台。到现在 2018 年，18 年时间过去了，其依然是我们最常用的虚拟机，可见 Sun HotSpot VM 的生命力之顽强。

### 百家争鸣：BEA JRockit / IBM J9 VM
前面说的都是 Sun 公司推出的虚拟机，但除了 Sun 公司之外，其他组织、公司也研发过不少的虚拟机实现，其中最著名的要算 BEA 公司的 BEA JRockit 和 IBM 公司的 J9 VM 了。

BEA 公司的 JRockit 是一款专注于服务器硬件和服务端应用场景的虚拟机，其针对服务端场景做了大量的优化，因此其不太关注程序启动速度。JRockit 虚拟机内部不包含解释器实现，全部代码都靠即时编译器编译后执行。此外，其提供的 MissionControl 服务套件也十分强大。

IBM 公司的 J9 VM 则是一款比较通用的虚拟机，其定位应用于从服务端到桌面应用再到嵌入式的多用途虚拟机。IBM 公司开发 J9 VM 的目的是将其作为 IBM 公司各种 Java 产品的执行平台。

### 武林外传：那些无名虚拟机
从 Sun Classic、Sun Exact VM、Sun HotSpot VM，再到 BEA JRockit、IBM J9 VM，这几个虚拟机可以说是虚拟机的正史了，是每个 Java 程序员应该了解的。但在这之外，其实还有各种各样的虚拟机存在。

例如性能最强悍的并不是上面所说的虚拟机，而是名为 Azul VM 和 BEA Liquid VM 的专用商业及虚拟机。这些虚拟机只运行在特定硬件平台，因此要求比较高。但其性能也是非常强悍的。其可以管理至少数十个 CPU 和数百 GB 的内存资源，还提供在巨大内存范围内实现可控 GC 时间的垃圾收集器等等。

此外还有许许多多其他的虚拟机存在，例如：Apache Harmony、Google Android Dalvik VM、Mircosoft JVM 等等。

### 最后的赢家：Oracle
看了这么些历史，似乎都是在说 Sun公司发布的虚拟机，与 Oracle 似乎没有什么关系。但在 2010 年，Oracle 公司收购了 Sun 公司，这样 Oracle 就拥有了 HotSpot VM。再加上其在 2008 年收购 BEA 公司获得的 JRocket VM，Oracle 公司就拥有了地球上最优秀的两款虚拟机。

对于虚拟机未来的规划，Oracle 宣布会将 JRockit 的优秀特性整合到 HotSpot VM 中，例如移植 JRockit 的垃圾回收器和 MissionControl 服务。

### 附录：Java 虚拟机历史
JDK 版本升级不仅仅体现在语言和功能特性上，还包括了其编译和执行的 Java 虚拟机的升级。

1. 1996 年，JDK 1.0 发布时，提供了纯解释执行的 Java 虚拟机实现：Sun Classic VM。
1. 1997 年，JDK 1.1 发布时，虚拟机没有做变更，依然使用 Sun Classic VM 作为默认的虚拟机。
1. 1998 年，JDK 1.2 发布时，提供了运行在 Solaris 平台的 Exact VM 虚拟机，但此时还是用 Sun Classic VM 作为默认的 Java 虚拟机。
1. 2000 年，JDK1.3 发布，默认的 Java 虚拟机由 Sun Classic VM 改为 Sun HotSopt VM，而 Sun Classic VM 则作为备用虚拟机。
1. 2002 年，JDK 1.4 发布，Sun Classic VM 退出商用虚拟机舞台，直接使用 Sun HotSpot VM 作为默认虚拟机一直到现在。


## 到底什么是虚拟机？
我们都知道在 Windows 系统上一个软件包装包是 exe 后缀的，而这个软件包在苹果的 Mac OSX 系统上是无法安装的。类似地，Mac OSX 系统上软件安装包则是 dmg 后缀，同样无法在 Windows 系统上安装。

为什么不同系统上的软件无法安装，这是因为操作系统底层的实现是不一样的。对于 Windows 系统来说，exe 后缀的软件代码最终编译成 Windows 系统能识别的机器码。而 Mac OSX 系统来说，dmg 后缀的软件代码最终编译成 Mac OSX 系统能识别的代码。

系统软件无法通用是一个常见的问题。但使用过 Java 的同学都知道，Java 代码可以在服务端（Linux 系统）运行，也可以在 Windows 系统运行，但我们并没有生成多份不同的代码。所以 Java 语言是如何做到的呢？

与其他语言不同，Java 语言并不直接将代码编译成与系统有关的机器码，而是编译成一种特定的语言规范，这种语言规范我们称之为字节码。无论 Java 程序要在 Windows 系统，还是 Mac OSX 系统，抑或是 Linux 系统，它首先都得编译成字节码文件，之后才能运行。

但即使编译成字节码文件了，各个系统还是无法明白字节码文件的内容，这时候就需要 Java 虚拟机的帮助了。Java 虚拟机会解析字节码文件的内容，并将其翻译为各操作系统能理解的机器码。

![](001.jpg)

简单地说，对于同样一份 Java 源码文件，我们编译成字节码之后，无论是 Linux 系统还是 Windows 系统都不认识。这时候 Java 虚拟机就是一个翻译官，在 Linux 系统上翻译成 Linux 机器码给 Linux 系统听，在 Windows 系统上翻译成 Windows 机器码给 Windows 系统听。这样一来，Java 就实现了「Write Once，Run Anywhere」的伟大愿景了。

在 Java 虚拟机还没出现之前，为了支持软件在不同系统上运行，我们必须在多个平台写多份代码，分别对应特定的系统。但 Java 虚拟机出现之后，你只需要按照特定规范编译书写，编译器编译成字节码文件后，虚拟机会帮你将字节码生成对应的 Windows Code 和 Mac Code。本质上最终还是会生成 Windows Code 和 Mac Code 两份机器代码，但对于开发人员来说，却只需要写一次代码了。Java 虚拟机帮开发人员承担了重复的工作，让开发效率更高了。

很多初学者关于 Java 虚拟机有一个误区，他们会觉得 Java 虚拟机只能运行 Java 代码。但实际上 Java 虚拟机运行的是字节码文件。换句话说，如果你用 php 语言写一段代码，并自己用特定编译器能生成符合字节码规范的字节码文件，那么 Java 虚拟机也是可以运行的。

所以虽然名字是 Java 虚拟机，但 Java 虚拟机与 Java 语言没有直接关系，它只按照 Java 虚拟机规范去读取 Class 文件，并按照规定去解析、执行字节码指令，仅此而已。

如果你够牛逼，你完全可以写一个编译器，将 PHP 语言代码编译成符合 Java 虚拟机规范的字节码文件，那么 Java 虚拟机也是可以执行的。

准确地说，Java 虚拟机与字节码文件（Class文件）绑定。

最后，让我们回顾一下，到底什么是虚拟机？其实 Java 虚拟机就是一个字节码翻译器，它将字节码文件翻译成各个系统对应的机器码，确保字节码文件能在各个系统正确运行。


## 从源代码到机器码，发生了什么？


## 字节码文件结构
Java 虚拟机使用字节码实现了跨平台的愿景，无论什么系统，我们都可以使用 Java 虚拟机解释执行字节码。其中，《Java 虚拟机规范》规定了Java 虚拟机结构、Class 类文件结构、字节码指令等内容。

字节码文件结构时一组以 8 位字节为基础的二进制流，各数据项目严格按照顺利紧凑地排列在 Class 文件之中，中间没用任何分隔符。在字节码结构中，有两种最基本的数据类型来表示字节码文件格式，分别是：无符号数和表。


## Java 虚拟机内存结构
看到这里，我相信大家对于一个 Java 源文件是如何变成字节码文件，以及字节码文件的含义已经非常清楚了。那么接下来就是让 Java 虚拟机运行字节码文件，从而得出我们最终想要的结果了。在这个过程中，Java 虚拟机会加载字节码文件，将其存入 Java 虚拟机的内存空间中，之后进行一系列的初始化动作，最后运行程序得出结果。

那么字节码数据在 Java 虚拟机内存中是如何存放的 ？Java 虚拟机在为类实例或成员变量分配内存是如何分配的 ？要解答上面这些问题，我们首先需要了解一下 Java 虚拟机的内存结构。

其实 Java 虚拟机的内存结构并不是官方的说法，在《Java 虚拟机规范》中用的是「运行时数据区」这个术语。但很多时候这个名词并不是很形象，再加上日积月累的习惯，我们都习惯用虚拟机内存结构这个说法了。

> **运行时数据区**
> Java 虚拟机定义了若干种程序运行时会使用的运行时数据区，其中一些会随着虚拟机创建而启动，随着虚拟机退出而销毁。另外一些则是与线程一一对应，这些与线程对应的数据区域会随着线程开始和结束而销毁。

根据《Java 虚拟机规范》中的说法，Java 虚拟机的内存结构可以分为公有和私有两部分。公有指的是所有线程都共享的部分，指的是 Java 堆、方法区、常量池。私有指的是每个线程的私有数据，包括：PC寄存器、Java 虚拟机栈、本地方法栈。

### Java 堆、方法区、常量池
在 Java 虚拟机中，线程共享部分包括 Java 堆、方法区及常量池。

Java 堆指的是从 JVM 划分出来的一块区域，这块区域专门用于 Java 实例对象的内存分配，几乎所有实例对象都在会这里进行内存的分配。之所以说几乎是因为有特殊情况，有些时候小对象会直接在栈上进行分配，这种现象我们称之为「栈上分配」。这里并不深入介绍，后续有章节会介绍。

方法区指的是存储 Java 类字节码的一块区域，它存储了每一个类的结构信息，例如运行时常量池、字段和方法数据、构造方法等。可以看到常量池其实是存放在方法区中的，但《Java 虚拟机规范》将常量池和方法区放在同一等级上，这点我们知道即可。

方法区在不同版本的虚拟机中有不同的表现形式，例如在 1.7 版本的 HotSpot 虚拟机中，方法区称为永久代（Permanent Space），而在 JDK 1.8 中则称之为 MetaSpace。

说完几个部分的大致作用后，我们来深入说说 Java 堆。

根据对象存活的时间不同，Java 堆还被分成年轻代、老年代两个区域，年轻代还被进一步分成 Eden 区、From Survivor 0、To Survivor 1 区。

![Java 堆](002.png)

当有对象需要分配时，一个对象永远优先被分配在年轻代的 Eden 区中。等到 Eden 区域内存不够时，Java 虚拟机会启动垃圾回收，此时 Eden 区中没用被引用的对象的内存就会被回收，而一些存活时间较长的对象则会进入到老年代。在 JVM 中有一个名为 `-XX:MaxTenturingThreshold` 的参数专门用来设置晋升到年老区所需经历的 GC 次数，即在年轻代的对象经过了指定次数的 GC 后，将在下次 GC 是进入老年代。

这里让我们思考一个问题：为什么 Java 堆要进行这样一个区域划分？

根据我们的经验，虚拟机中必要有存活时间很长的对象，也有存活时间很短的对象，这是一个普遍存在的正态发布规律。如果我们将其混在一起，那么因为存活时间短的对象有很多，势必导致频繁的垃圾回收。而垃圾回收时不得不对所以内存进行扫描，但是其实有一部分对象的存活时间很长，对它们进行扫描完全是浪费时间。因此为了提高垃圾回收效率，分区是理所当然了。

另外一个值得思考的问题是：为什么默认的虚拟机配置，Eden : from : to = 8 : 1 :1 呢？

其实这是根据 IBM 公司大量统计得出的结果。根据 IBM 公司对对象存活时间的统计，他们发现 80% 的对象存活时间都很短。于是他们将 Eden 区设置为年轻代的 80%，这样可以减少内存空间的浪费，提高内存空间利用率。

### PC 寄存器、Java 虚拟机栈、本地方法栈

Java 堆以及方法区是共享的，但是有一部分则是线程私有的。线程私有部分可以分为：PC 寄存器、Java 虚拟机栈、本地方法栈三大部分。

PC 寄存器，指的是保存线程当前正在执行的方法。如果这个方法不是 native 方法，那么 PC  寄存器就保存 Java 虚拟机正在执行的字节码指令地址。如果是 native 方法，那么 PC 寄存器保存的值是 undefined。任意时刻，一条 Java 虚拟机线程只会执行一个方法的代码，而这个被线程执行的方法称为该线程的当前方法，其地址被存在 PC 寄存器中。

Java 虚拟机栈，这个栈与线程同时创建，用来存储栈帧，即存储局部变量与一些过程结果的地方。栈帧存储的数据包括：局部变量表、操作数栈。

当 Java 虚拟机使用其它语言（例如 C 语言）来实现指令集解释器时，也会使用到本地方法栈。如果 Java 虚拟机不支持 native 方法，并且自己也不依赖传统栈的话，可以无需支持本地方法栈。

### 总结
一个 Java 类加载到内存中，Java 类的信息会存储在我们的方法区中。如果创建对象，那么对象数据会存放在 Java 堆中。如果调用方法，就会用到 PC 寄存器、Java 虚拟机栈、本地方法栈等结构。


## JVM 类加载机制
类加载机制就是虚拟机将字节码加载进内存，从而进行解析、运行等整个过程，它大致可以分为七个阶段：**加载**、**验证**、**准备**、**解析**、**初始化**、**使用**、**卸载**。

### 加载
加载阶段是指类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是将字节码从各个位置（网络、磁盘）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。

### 验证
当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM　便会启动对该字节码的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。这个校验过程大致可以分为以下几类：
- JVM 规范校验
    JVM 会对字节码进行文件格式校验，判断其是否符合 JVM 规范，是否能被当前版本的虚拟机处理。
    例如文件是否以 `0x cafe bene` 开头，主次版本号是否在当前虚拟机处理范围内。
- 代码逻辑校验
    JVM 会对代码组成的数据流和控制流进行校验，确保 JVM 运行该代码文件后不会出现致命错误。
    例如一个方法要求传入 `int` 类型的参数，但是使用它的时候却传入了一个 `String` 类型的参数。

### 准备（重点）
当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。这里需要注意两个关键点：即内存分配的对象以及初始化的类型。
- 内存分配的对象
    Java 中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 `static` 修饰的变量，而其他所有类型的变量都属于「类成员变量」。在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。
    例如下面的代码在准备阶段，只会为 `factor` 属性分配内存，而不会为 `website` 属性分配内存。

    ```java
    public static int factor = 3;
    public String website = "zhangqinghua.github.io";
    ```
- 初始化的类型
    在准备阶段，JVM 会为「类变量」分配内存，变为其初始化。但是这里的初始化指的是为变量赋值 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。
    例如下面代码在准备阶段只会，`sector` 的值将是 0，而不是 3。
    ```java
    public static int sector = 3;
    ```
    但如果一个变量是常量（被 `static final` 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值。例如下面代码在准备阶段之后，`number` 将是 3，而不是 0。
    ```java
    public static final int number = 3;
    ```
    `final` 关键字在 Java 中代表不可改变的意思，即 number 的值一旦赋值就不会改变了，所以需要在一开始就给其赋予用户需要的值。而没有被 `final` 修饰的类变量，其可能在初始化阶段或者运行阶段发生变化，所以就没有必要在准备阶段对它赋予用户想要的值。

### 解析
当通过了准备阶段之后，JVM 针对类或者接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接在内存中的直接引用。

### 初始化（重点）
到了初始化阶段，用户定义的 Java 程序代码才开始真正执行。在这个阶段，JVM 会根据语句执行顺利对类对象进行初始化，一般来说当 JVM 遇到以下 5种情况的时候会触发初始化：
- 遇到 `new`、`getstatic`、`putstatic`、`invokestatic` 这四个字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这 4 个指令的最常见的 Java 代码场景是：使用 `new` 关键字实例化对象的时候、读取或者设置一个类的静态字段（被 `final` 修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
- 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
- 当初始化一个类时，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。
- 当使用 JDK1.7 动态语言支持时，如果一个 `java.lang.invoke.MethodHandle` 实例最后的解析结果是 `REF_getstatic`、`REF_putstatic`、`REF_invokeStatic` 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先触发其初始化。

### 使用
当 JVM 完成初始化阶段后，JVM 便开始从入口方法执行用户的代码。

### 卸载
当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。

### 总结
类构造器是指按顺序收集到的类中所有的静态代码块、类变量赋值语句。

对象构造器是指按顺序收集到的成员变量赋值语句、普通代码块，最后收集构造函数。

```java
public class Book {
	public static void main(String[] args) {
		staticFunction();
	}

	static Book book = new Book();

	static {
		System.out.println("书的静态代码块");
	}

	{
		System.out.println("书的普通代码块");
	}

	Book() {
		System.out.println("书的构造方法");
		System.out.println("price=" + price + ",amount=" + amount);
	}

	public static void staticFunction() {
		System.out.println("书的静态方法");
	}

	int price = 110;
	static int amount = 112;
}
```

在上面这个例子中，类构造器组成是：
```java
static Book book = new Book();
static {
	System.out.println("书的静态代码块");
}
static int amount = 112;
```

对象构造器组成是：
```java
{
	System.out.println("书的普通代码块");
}
int price = 110;
Book() {
	System.out.println("书的构造方法");
	System.out.println("price=" + price + ",amount=" + amount);
}
```

分析一个类的执行顺利大概可以按照如下步骤：
1. 确定类变量的初始值
    在类加载的准备阶段，JVM 会为类变量初始化零值，这时候类变量会有一个初始的零值。如果被 final 修复的类变量，则直接会被初始化成用户想要的值。
1. 初始化入口方法
    当进入类加载的初始化阶段后，JVM 会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。当需要对一个类进行初始化时，会首先初始化类构造器，之后初始化对象构造器。
1. 初始化类构造器
    JVM 会按顺利收集类变量的赋值语句、静态代码块，最终组成类构造器由 JVM 执行。
1. 初始化对象构造器
    JVM 会按照顺利收集成员变量的赋值语句、普通代码块，最后收集构造方法，将它们组成对象构造器，最终由 JVM 执行。

如果在初始化 main 方法所在类的时候遇到其他类的初始化，那么就先加载对应的类，加载完成之后返回。如果反复执行，最终返回 main 方法所在的类。

- 类构造器

## JVM 垃圾回收机制
因为内存总是有限的，我们需要一个机制来不断回收废弃的内存，从而实现内存的循环利用，这样程序才能正常运转下去。

### 到底谁是垃圾
在 Java 中，如果一个对象不可能再被引用，那么这个对象就是垃圾，应该被回收。

现今的 Java 虚拟机判断垃圾对象使用的是：GC Root Tracing 算法。其大概过程是这样子的：从 CG Root 出发，所有可达的对象都是存活的对象，而所有不可达的对象都是垃圾。

可以看到这里最重要的就是 GC Root 这个集合了，其实 CG Root 就是一组活跃引用的集合。但是这个集合又与一般的对象集合不太一样，这些集合是经过特意筛选出来的，通常包括：
- 所有当前被加载的 Java 类
- Java 类的引用类型静态变量
- Java 类的运行时常量池的引用类型常量
- JVM 的一些静态数据结构里指向 GC 堆里的对象的引用
- 等等

简单的说，GC Root 就是经过精心挑选的一组活跃引用，这些引用是肯定存活的。那么通过这些引用延伸到的对象，自然也是存活的。

### 如何进行垃圾回收
垃圾回收算法简单地说有三种：标记清除算法、复制算法、标记压缩算法。

1. 标记清除算法
    最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。
    该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。
    ![](003.jpg)
1. 复制算法
    为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。
    这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。
    ![](004.jpg)
1.  标记压缩算法
    结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。
    ![](005.jpg)

### JVM 中的垃圾回收
目前大部分 JVM 采用的是分代收集算法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为年轻代和老年代。老年代的特点是每次垃圾回收时只有少量对象需要回收，年轻代的特点时每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同算法。

目前大部分 JVM 的 GC 对于年轻代采用复制算法，因为年轻代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少。每次使用 Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。

![](006.jpg)

对象的内存分配主要在年轻代的 Eden 区域和 From Servivor （Servivor 目前存放对象的那一块），少数情况会直接分配到老年代。当年轻代的 Eden 和 Survivor From 空间不足时就会发生一次 GC，进行 GC 后，Eden 和 Survivor From 区的存活对象就会被挪到 Survivor To 区去，然后将 Eden 和 Survivor From 进行清理。如果 Survivor To 区无法足够存储某个对象，则将这个对象存储到老年代。在进行 GC 后，使用的便是 Eden 和 Survivor To 了。如此反复循环，当对象在 Survivor 区躲过一次 GC 后，其年龄就会 +1。默认情况下年龄达到 15 的对象就会被移到老年代中。

### 总结
![](007.png)

## JVM 中的垃圾回收器
Java 虚拟机的垃圾回收器可以分为四大类：**串行回收器**、**并行回收器**、**CMS 回收器**、**G1 回收器**。

### 串行回收器
串行回收器是指使用单线程进行垃圾回收的回收器。因为每次回收时只有一个线程，因此串行回收器在并发能力较弱的计算机上，其专注性和独占性的特点往往能让其有更好的性能表现。

![](008.png)

串行收集器是所有垃圾回收器中最古老的一种，也是 JDK 中最基本的垃圾回收器之一。串行回收器可以在新生代和老年代使用，根据作用于不同的堆空间，分为新生代串行回收器和老年代串行回收器：

**新生代串行回收器**
- 作用于新生代
- 使用复制算法
- 进行垃圾回收时，会触发 Stop-The-World 现象，即其他现场都需要暂停，等待垃圾回收完成。
- 使用 `-XX:+UseSerialGC` 参数可以指定使用新生代串行收集器和老年代串行收集。当虚拟机在 Client 模式下运行时，其默认使用该垃圾收集器。

**老年代串行回收器**
- 作用于老年代
- 使用标记压缩算法
- 进行垃圾回收时，会触发 Stop-The-World 现象（通常老年代垃圾回收比新生代回收要更长时间, 所以可能会使应用程序停顿较长时间）。
- 可以与多种新生代回收器配合使用
    - `-XX:+UseSerialGC`：新生代、老年代都使用串行回收器。
    - `-XX:+UseParNewGC`：新生代使用 ParNew 回收器，老年代使用串行回收器。
    - `-XX:+UsrParallelGC`：新生代使用 ParallelGC 回收器，老年代使用串行回收器。

### 并行回收器
并行回收器在串行回收器的基础上做了改进，其使用多线程进行垃圾回收。对于并行能力强的机器，可以有效缩短垃圾回收所使用的时间。

![](009.png)

根据作用内存区域的不同，并行回收器也有三个不同的回收器：新生代 ParNew 回收器、新生代 ParallelGC 回收器、老年代 ParallelGC 回收器。

**新生代 ParNew 回收器**
- 简单地将串行回收器多线程化
- 作用于新生代
- 使用复制算法 
- 仍然触发 Stop-The-World 现象，但因为其使用多线程进行垃圾回收，因此在并发能力强的 CPU 上，其产生的停顿时间要短于串行回收器。
- 在单 CPU 或者并行能力弱的系统上，并行回收器效果会因为线程切换的原因，其实际表现效果反而不如串行回收器。
- `XX:+UseParNewGC` 新生代使用ParNew回收器, 老年代使用串行回收器 
- `XX:+UseConcMarkSweepGC` 新生代使用ParNew回收器, 老年代使用CMS回收器 
- `XX:ParallelGCThreads=n` 指回ParNew回收器工作时的线程数量, cpu核数小时8时, 其值等于cpu数量, 高于8时,可以使用公式(3+((5*CPU_count)     /8))

**新生代 ParallelGC 回收器**
- 同新生代 ParNew 回收器
- 非常关注系统的吞吐量（通过参数控制）
    - `-XX:+UseAdaptiveSizePolicy` 使用自适应 GC 调节策略
    - `-XX:MaxGCPauseMillis` 设置最大垃圾收集停顿时间。在 ParallelGC 工作时，其会自动调整响应参数，将停顿时间控制在设置范围内。为了达 到这个目的，其可能会使用较小的堆，导致较为频繁的 GC。
    - `-XX:GCTimeRatio` 设置吞吐量大小，其实是一个 0-100的整数。假设 GCTimeRatio 的值为 n，那么系统将不花费超过 1/(1+n) 的时间用于垃圾回收。比如 GCTimeRatio 值为 19，那么系统用于垃圾收集的时间不超过 1/(1+19)=5%。默认情况下，它的取值是 99，即不超过 1%。
- `-XX:+UseParallelGC` 新生代使用 Parallel 回收器，老年代使用串行回收器。
- `-XX:+UseParallelOldGC` 新生代使用 ParallelGC 回收器，老年代使用 ParallelOldGC 回收器。

**老年代 ParallelOldGC 回收器**
- 新生代 ParallelGC 回收器
- 作用于老年代
- 使用标记压缩算法
- `-XX:UseParallelOldGC` 在新生代中使用 ParallelGC 收集器，在老年代中使用 ParallelOldGC 收集器
- `-XX:ParallelGCThreads` 用于设置垃圾回收时的线程数量

### GMS 回收器
CMS 回收器主要关注系统停顿时间。CMS 回收器全称为 Concurrent Mark Sweep，意为标记清除算法，其是一个使用多线程并行回收的垃圾回收器。

**工作步骤**
1. 初始标记
1. 并发标记
1. 预清理
1. 重新标记
1. 并发清除
1. 并发充值

其中初始标记和重新标记是独占系统资源的，而其他阶段则可以和用户线程一起执行。


## 实战分析

1. 第一个例子
    ```java
    class Grandpa {
        static {
            System.out.println("爷爷在静态代码块");
        }
    }
    class Father extends Grandpa {
        static {
            System.out.println("爸爸在静态代码块");
        }

        public static int factor = 25;

        public Father() {
            System.out.println("我是爸爸~");
        }
    }
    class Son extends Father {
        static {
            System.out.println("儿子在静态代码块");
        }

        public Son() {
            System.out.println("我是儿子~");
        }
    }
    public class InitializationDemo {
        public static void main(String[] args) {
            System.out.println("爸爸的岁数:" + Son.factor); //入口
        }
    }
    // 爷爷在静态代码块
    // 爸爸在静态代码块
    // 爸爸的岁数:25
    ```
    1. 首先程序到 main 方法这里，使用标准化输出 `Son` 类中的 `factor` 类成员变量，但是 `Son` 类中没有这个类成员变量。于是往父类去找。我们在 `Father` 类中找到了对应的类成员变量，于是触发了 `Father` 的初始化。
    1. 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。所以我们先初始化 Father 的父类，也就是先初始化 Grandpa 类再初始化 Father 类。于是我们初始化 Grandpa 类输出：”爷爷在静态代码块“，再初始化 Father 类输出：”爸爸在静态代码块“。
    1. 最后，所有的父类都初始化完毕，Son 类才能调用父类的静态变量，从而输出”爸爸的岁数:25“。
    对于静态字段，只有直接定义这个字段的类才会被初始化执行（执行静态代码块）。因为通过其字类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发字类的初始化。
1. 第二个例子
    ```java
    class Grandpa {
        static {
            System.out.println("爷爷在静态代码块");
        }

        public Grandpa() {
            System.out.println("我是爷爷~");
        }
    }
    class Father extends Grandpa {
        static {
            System.out.println("爸爸在静态代码块");
        }

        public Father() {
            System.out.println("我是爸爸~");
        }
    }
    class Son extends Father {
        static {
            System.out.println("儿子在静态代码块");
        }

        public Son() {
            System.out.println("我是儿子~");
        }
    }
    public class InitializationDemo {
        public static void main(String[] args) {
            new Son(); //入口
        }
    }
    // 爷爷在静态代码块
    // 爸爸在静态代码块
    // 儿子在静态代码块
    // 我是爷爷~
    // 我是爸爸~
    // 我是儿子~
    ```
    1. 首先在入口这里我们初始化一个 `Son` 对象，因此触发 `Father`，`Grandpa` 类的初始化。
    1. 当 `Son` 初始化之后，便会调用 `Son` 类的构造方法，而 `Son` 类构造方法的调用同样会带动 `Father`、`Grandpa` 类构造方法的调用。
1. 第三个例子
    ```java
    public class Book {
        public static void main(String[] args) {
            staticFunction();
        }

        static Book book = new Book();

        static {
            System.out.println("书的静态代码块");
        }

        {
            System.out.println("书的普通代码块");
        }

        Book() {
            System.out.println("书的构造方法");
            System.out.println("price=" + price + ",amount=" + amount);
        }

        public static void staticFunction() {
            System.out.println("书的静态方法");
        }

        int price = 110;
        static int amount = 112;
    }
    // 书的普通代码块
    // 书的构造方法
    // price=110,amount=0
    // 书的静态代码块
    // 书的静态方法
    ```
    1. 在 JVM 准备阶段的时候，便会为类变量分配内存和进行初始化。此时，我们的 `book` 实例变量初始化为 `null`，`amount` 变量初始化为 0。
    1. 当进入初始化阶段后，因为 `Book` 方法是程序的入口，所以 JVM 会初始化 `Book` 类。
    1. JVM 对 `Book` 类进行初始化首先是执行类构造器，后执行对象的构造器。
    1. 对于 `Book` 类，其类构造器是：
        ```java
        static Book book = new Book();
        static {
            System.out.println("书的静态代码块");
        }
        static int amount = 112;
        ```
    1. 由于 `static Book book = new Book();` 这一条语句，又触发了类的实例化。于是 JVM 执行对象构造器：
        ```java
        {
            System.out.println("书的普通代码块");
        }
        int price = 110;
        Book() {
            System.out.println("书的构造方法");
            System.out.println("price=" + price + ",amount=" + amount);
        }
        ```
    1. 此时 `price` 赋值 110，输出「书的普通代码块」、「书的构造方法」、「price=110,amount=0」（`amount` 的赋值语句并未执行，所以只有在准备阶段赋值的零值）。
    1. 当类实例化完成之后，JVM 继续进行类构造器的初始化，即输出「书的静态代码块」，之后对 `amount` 赋予 112 的值。
    1. 到这里，类的初始化已经完成，JVM 执行 main 方法的内容：
        ```java
        public static void main(String[] args) {
            staticFunction();
        }
        ```

```java
class Grandpa {
    static {
        System.out.println("爷爷在静态代码块");
    }
}

class Father extends Grandpa {
    static {
        System.out.println("爸爸在静态代码块");
    }

    public static int age = 25;

    public Father() {
        System.out.println("我是爸爸~");
    }
}

class Son extends Father {
    static {
        System.out.println("儿子在静态代码块");
    }

    public Son() {
        System.out.println("我是儿子~");
    }
}

public class InitializationDemo {
    public static void main(String[] args) {
        System.out.println("爸爸的岁数:" + Son.age);  //入口
    }
}
```