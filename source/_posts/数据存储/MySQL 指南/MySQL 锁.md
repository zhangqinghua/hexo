---
title: MySQL 锁

categories:
- 数据存储
- MySQL 指南

date: 2020-04-28 00:00:91
---
只有正确指定主键，才会执行行锁，否则执行表锁。

无锁
```sql
select * from user where id = -1 for update;
```

行锁
```sql
select * from user where id = 1 fro update;

select * from user where id = 1 and name = 'kkk' for update;
```

表锁
```sql
-- 主键不明确
select * from user where name = 'kkk' for update;
select * from user where id <> 3 for update;
```

## 锁算法
#### 行锁算法
Record Lock（普通行锁）
1. 键值在条件范围内
1. 记录存在

Gap Lock（间隙锁）
1. 对于键值不存条件范围内，叫做“间隙”（GAP），引擎会对这个“间隙”加锁，这种机制叫做GAP机制。

Next-Key Lock（行 & 间隙）
1. 在键值范围条件内，同时键值又不存在条件范围内
    ```sql
    -- id 只有 50
    select * from user where id > 49 for update;
    ```

#### 表锁算法
意向锁（升级机制）
1. 当一个事务带着表锁去访问一个被加了行锁的资源，那么此时这个行锁就会升级为意向锁，将表锁定。
    ```sql
    -- 事务 A 升级表锁
    select * from user where id = 10 for update;

    -- 事务 B 锁表
    select * from user where name like 'kkk%' for update;
    ```
自增锁
1. 事务插入自增类型的列时，获取自增锁
    如果一个事务正在往表插入自增记录，其它事务都必须等待

## 实现
共享锁 & 排它锁

> 行锁和表锁其实是粒度的概念，共享锁和排它锁是它们的具体实现

共享锁
1. 允许一个事务去度一行，阻止其它事务去获取该行的排它锁
1. 一般理解：能度，不能写

排它锁：写锁
1. 允许持有排它锁的事务读取数据，阻止其它事务获取该资源的共享锁和排它锁
1. 不能访问任何锁，不代表不能读

注意点
1. 某个事务获取数据的排它锁，其它事务不能获取该数据的任何锁，并不代表其它事务不能无锁读取该数据
    ```sql
    -- 无锁
    select ... from ....

    -- 共享锁
    -- MySQL 8.0 以上，for share 代替了 lock in share mode
    select ... lock in share mode

    -- 排它锁
    update ...
    delete ...
    insert ...
    select ... for update
    ```
## 乐观锁 & 悲观锁
> 不管什么锁都需要加失败重试

乐观锁
1. 一般通过版本号进行更新
    ```sql
    upate user set name = 'www' where id = 1 and version = 1;
    ```
悲观锁

## 原理

## 什么是锁
锁是计算机协调多个进程或线程并发访问同一资源的机制（避免资源争抢）。

加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。

## 锁分类
从对数据操作的粒度分：
1. 表锁：操作时，会锁定整个表
1. 行锁：操作时，会锁定当前操作行

从对数据操作的类型分：
1. 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会相互影响。
1. 写锁（排它锁）：当前操作没有完成之前，它会阻断其它写锁和读锁。

## MySQL锁
相对其它数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。下表中罗列了各种存储引擎对锁的支持情况：

|存储引擎|表级锁|行级锁|页面锁|
| :-- |
|MyISAM|支持|不支持|不支持|
|InnoDB|支持|支持|不支持|
|MEMORY|支持|不支持|不支持|
|DBD|支持|不支持|支持|

MySQL 这 3 种锁的特性可大致归纳如下：

|锁类型|特点|
| :-- |
|表级锁|偏向 MyISAM 存储引擎，开销小；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最小|
|行级锁|偏向 InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高|
|页面锁|开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁直接，并发度一般|

从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更适合！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如 Web 应用。而行锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（OLTP）系统。

## MyISAM 表锁
MyISAM 存储引擎只支持表锁，这也是 MySQL 开始几个版本中唯一支持的锁类型。

#### 如何加锁
MyISAM 在开始执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（INSERT、UPDATE、DELETE 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令 MyISAM 表显式加锁。

显式加表锁语法：
```sql
-- 加读锁
lock table table_name read;

-- 加写锁
lock table table_name write;
```

```sql
-- book 表 user表

-- 客户端1，加book读锁
lock table book read;

-- 客户端1，能正常读book数据
select * from book;

-- 客户端2，能正常读book数据（读锁，共享锁）
select * from book;

-- 客户端1，不能读user数据，因为已经锁定了book，不能访问其它表
select * from user;

-- 客户端2，能读user数据，因为没有锁
select * from user;

-- 客户端1，不能写book数据，因为是读锁
update book set name = 'Solr';

-- 客户端2，写book数据进入阻塞状态，需要客户端1释放表锁才能继续进行
update book set name = 'Solr';
```

理解：
1. 表的读锁和写锁同时只能有一个。一个客户端同一时间只能拥有一个锁。
1. 当一个客户端拥有了一个表的读锁时，只能拥有此表的读权限，不能修改，不能操作其它表。
1. 其它客户端可以共享此锁（不拥有此锁），可以访问此表数据，也可以操作其它表数据。
1. 一个客户端同一时间只能拥有一个锁。所以其它客户端要修改此表，只能等待锁释放了。

test:
1. 当一个线程拥有了一个表的读锁，它不会阻塞其它线程的读操作，会阻塞写操作。

## 结论
锁模式的相互兼容性：

|当前锁模式|无请求|读请求锁|写请求锁|
| :-- |
|读锁|是|是|否|
|写锁|是|否|否|

由上表可见：
1. 对 MyISAM 表的读操作，不会阻塞其它用户对同一表的读请求，但会阻塞对同一表的写请求。
1. 对 MyISAM 表的写操作，则会阻止其它用户对同一表的读和写操作。

此外，MyISAM 的读写锁调度是写优先，这也是 MyISAM 不适合做写为主的表的存储引擎的原因。因为写锁后，其它线程不能做任何操作，大量的更新会使得查询很难得到锁，从而造成永远阻塞。

## 锁的操作
```sql
-- 查询锁的争用情况
show open tables;

-- 查询表的锁定情况
show status like 'Table_lo%'
```




## 行锁介绍
行锁是偏向 InnoDB 存储引擎，开销大，加锁慢，会出现死锁，锁的粒度最小，发生锁冲突的概率最低，并发度也最高。

InnoDB 与 MyISAM 的两个最大不同点是：一支持事务，而采用了行锁。

## 背景知识

#### 事务及其 ACID 属性
事务是由一组 SQL 语句组成的逻辑处理单元。

事务具有以下 4 个特性，简称为事务的 ACID 属性。

|ACID 属性|含义|
| :-- |
|原子性|事务是一个原子操作，其对数据的修改，要么全部成功，要么全部失败|
|一致性|在事务开始和完成时，数据都必须保持一致状态|
|隔离性|数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境运行|
|持久性|事务完成之后，对于数据的修改是永久性的|

#### 并发事务处理带来的问题

|问题|含义|
|丢失更新|当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖|
|脏独|当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问了这个数据，然后使用了数据|
|不可重复读|一个事务在读取某些数据时，再次读取以前读过的数据，却发现和以前读出的数据不一致|
|幻读|一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其它事务插入了满足其查询条件的新数据|

#### 事务的隔离级别
为了解决上诉提到的事务并发问题，数据库提供了一定的事务隔离机制来解决这个问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使用事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。

数据库的隔离级别有 4 个，由低到高依次为读未提交、读已提交、可重复读、串行化，这四个级别解决了脏写、脏读、不可重复读、幻读这几类问题。

|隔离级别|丢失更新|脏读|不可重复读|幻读|
| :-- |
|Read uncommited|x|y|y|y|
|Read commited|x|x|y|y|
|Repeatable read|x|x|x|y|
|Serializable|x|x|x|x|

MySQL 的数据库的默认隔离级别为 Repeatable read，查看方式为：

```sql
sho variables tx_Isolation;
```

## InnoDB 的行锁模式

## 案例准备工作

## 行锁基本演示

## 行锁升级为表锁
如果不通过索引条件检索数据， 那么 InnoDB 将对表中所有记录都加锁，实际效果和表锁是一样的。

> 如果一个 VARCHAR 类型的索引列（如用户名）没有加单引号（where name = 900 & where name = '900'），则索引失效。

## 间隙锁危害
当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排它锁，InnoDB 会给符合条件的已有数据进行加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。

## InnoDB 行锁争用情况
```sql
show status like 'innodb_row_lock%'
```

## 总结
InnoDB 存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能耗损可能会比表锁更高一点，但是在整体并发处理能力方面要远远高于 MyISAM 的表锁。当系统并发量较高时，InnoDB 的整体性能和 MyISAM 相比就会有比较明显的优势。

但是，InnoDB 的行级锁同样也有其脆弱的一面，当我们使用不当时，可能会让 InnoDB 的整体性能表现不仅不能比 MyISAM 高，甚至可能会更差。

优化建议：
1. 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁
1. 合理设计索引，尽量缩小锁的范围
1. 尽可能检索索引条件，及索引范围，避免间隙锁
1. 尽量可能事务大小，减少锁定资源量和时间长度
1. 尽可能使用低级别事务隔离（但是需要满足业务层面需求）


## 索引的优点

## 索引的缺点

## 索引性能对比
#### 案例 1
在通常情况下，有索引的情况下查询比较快，插入比较慢，所以在大批量的数据导入操作中应该首先删除索引，待数据导入完成后再建立索引。

|表名|表属性|当前数据量|插入（秒）|查询（秒）|删除（秒）|
| :-- | :-- | :-- |
|test1|有索引|50W|0.15|1.67|
|test2|无索引|50W|0.00|2.53|
|test1|有索引|100W|||
|test2|无索引|100W|||
|test1|有索引|200W|||
|test2|无索引|200W|||

#### 案例 2
|操作|无索引|单个索引|多个索引|
| :-- | :-- | :-- | :-- |
|插入 3000 记录|
|插入 19000 记录|

[](https://www.cnblogs.com/ssslinppp/p/8423472.html)

#### 案例 3
[](https://blog.csdn.net/lenux2017/article/details/80086265)

对 200000 条数据的查询结果对比。

|表属性|插入（秒）|查询（秒）|删除（秒）|
| :-- |
|无索引||0.15|
|有索引||0.09|


## 什么时候使用索引

## 什么时候不使用索引
尽管创建索引的目的是提升数据库的性能，但是还是有一些情况应当避免使用索引。下面几条指导原则给出了何时应当重新考虑是否使用索引：

- 小的数据表不应当使用索引

- 需要频繁进行大批量的更新或者插入操作的表

- 如果列中包含大数或者 NULL 值，不宜创建索引

- 频繁操作的列不宜创建索引

## 索引设计原则
1. 对查询频率较高，且数据量较大的表建立索引
1. 索引字段的选择，最佳候选列应当从where子句的条件中提取。
1. 使用唯一索引，区分度越高，索引效率越高
1. 索引不是越多越好，维护索引的代价也大
1. 使用短索引，索引创建后也是使用磁盘来存储的，因此提升索引访问的I/O效率很重要
1. 利用最左前缀，N个列组合而成的组合索引，那么相当于创建了N个索引。