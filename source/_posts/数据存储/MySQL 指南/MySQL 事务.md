---
title: MySQL 事务

categories:
- 数据存储
- MySQL 指南

date: 2020-04-28 00:00:81
---
事务是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。

## ACID
如果一个数据库声称支持事务的操作，那么该数据库必须要具备以 ACID 4个特性。

#### 原子性
原子性（Atomicity）是指一个事务所包含的操作要么全部成功，要么全部失败回滚。

#### 一致性
一致性（Consistency）是指一个事务执行之前和执行之后都必须处于一致性状态。

拿转账来说，假设用户 A 和用户 B 两者的钱加起来一共是 5000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 5000，这就是事务的一致性。

#### 隔离性
隔离型（Isolation）是指当多个用户并发访问数据库时，比如操作同一张表，数据库为每一个用户开启事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

#### 持久性
持久性（Durability）是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

## 并发问题
#### 脏读
脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据（**针对未提交数据**）。

当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户 A 向用户 B 转账 100 元，对应 SQL 命令如下：

```sql
update account set money = money + 100 where name = 'B';    

update account set money = money - 100 where name = 'A';
```

当只执行第一条 SQL 时，A 通知 B 查看账户，B 发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当 B 以后再次查看账户时就会发现钱其实并没有转。

#### 不可重复读
不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了（**针对其他提交前后，读取数据本身的对比**）。

例如事务 T1 在读取某一数据，而事务 T2 立马修改了这个数据并且提交事务给数据库，事务 T1 再次读取该数据就得到了不同的结果，发送了不可重复读。

不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据 A 和 B 依次查询就可能不同，A 和 B 就可能打起来了……

#### 虚读（幻读）
幻读是事务非独立执行时发生的一种现象。例如事务 T1 对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读（**针对其他提交前后，读取数据条数的对比**）。

幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

## 隔离级别
MySQL 数据库为我们提供了 4 种隔离级别。

#### Read uncommitted
Read uncommitted (读未提交)，最低级别，任何情况都无法保证。

它是最低的隔离级别，它最直接的效果就是一个事务可以读取另一个事务并未提交的更新结果。

#### Read committed
Read committed (读已提交)，可避免脏读的发生。

它通常是大部分数据库采用的默认隔离级别，它在 Read Uncommitted 隔离级别基础上所做的限定更进一步，在该隔离级别下，一个事务的更新操作结果只有在该事务提交之后，另一个事务才可能读取到同一笔数据更新后的结果。所以，Read Committed 可以避免 Read Uncommitted 隔离级别下存在的脏读问题，但无法避免不可重复读取和幻读的问题。

#### Repeatable read
Repeatable read (可重复读)，可避免脏读、不可重复读的发生。

此隔离级别可以保证在整个事务的过程中，对同一笔数据的读取结果是相同的，不管其他事务是否同时在对同一笔数据进行更新，也不管其他事务对同一笔数据的更新提交与否。Repeatable Read 隔离级别避免了脏读和不可重复读取的问题，但无法避免幻读。（MySQL 默认隔离级别）

#### Serializable
Serializable (串行化)，可避免脏读、不可重复读、幻读的发生。

最为严格的隔离级别，所有的事务操作都必须依次顺序执行，可以避免其他隔离级别遇到的所有问题，是最为安全的隔离级别， 但同时也是性能最差的隔离级别，因为所有的事务在该隔离级别下都需要依次顺序执行，所以，并发度下降，吞吐量上不去，性能自然就下来了。 因为该隔离级别极大的影响系统性能，所以，很少场景会使用它。通常情况下，我们会使用其他隔离级别加上相应的并发锁的机制来控制对数据的访问，这样既保证了系统性能不会损失太大，也能够一定程度上保证数据的一致性。

## 隔离级别操作
```sql
-- 查看当前事务的隔离级别
select @@tx_isolation;

-- 设置隔离级别
set transaction isolation level repeatable read;

set tx_isolation = 'repeatable-read';
```

#### 不同隔离级别性能差异