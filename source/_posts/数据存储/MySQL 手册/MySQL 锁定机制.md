---
title: MySQL 锁定机制

categories:
- 数据存储
- MySQL 手册

date: 2020-07-07 00:00:06
---

## 锁的种类
从类型上来看，可以分为共享锁、排它锁。从范围来看，可以分为表锁、行锁，间隙锁、页锁等。其中表锁中又有意向锁。以上锁根据存储引擎不同，生效的锁也不同。

1. 共享锁
   事务拿到某一行记录的共享锁，才可以读取这一行，并阻止别的事物对其添加X锁。
   共享锁的目的是提高读读并发

1. 排他锁
   事务拿到某一行记录的排它锁，才可以修改或者删除这一行。
   排他锁的目的是为了保证数据的一致性

1. 意向共享锁
   预示事务有意向对表中的某些行加共享锁。

1. 意向排他锁
   预示着事务有意向对表中的某些行加排他锁。

1. 记录锁
   对单条索引记录进行加锁，锁住的是索引记录而非记录本身，即使表中没有任何索引，MySQL会自动创建一个隐式的 `row_id` 作为聚集索引来进行加锁。

1. 间隙锁
   封锁记录中的间隔，防止间隔中被其他事务插入。

   间隙锁主要出现在RR隔离级别，避免出现幻读。

## 锁的支持
在 MySQL 中，不同的存储引擎支持不同的锁机制。比如，MyISAM 和 MEMORY 存储引擎采用的是表级锁；BDB 存储引擎采用的是页面锁，但也支持表级锁；InnoDB 存储引擎既支持行级锁，也支持表级锁，但默认情况下是采用行级锁。

## 锁的对比


## 间隙锁
当我们采用范围条件查询数据时，InnoDB 会对这个范围内的数据进行加锁。比如有 `id` 为：1、3、5、7 的 4 条数据，我们查找 1-7 范围的数据。那么 1-7 都会被加上锁。2、4、6 也在 1-7 的范围中，但是不存在这些数据记录，这些 2、4、6 就被称为间隙。

#### 间隙锁的危害
范围查找时，会把整个范围的数据全部锁定住，即便这个范围内不存在的一些数据，也会被无辜的锁定住，比如我要在 1、3、5、7 中插入 2，这个时候 1-7 都被锁定住了，根本无法插入 2。在某些场景下会对性能产生很大的影响。

#### 间隙锁的触发
1. 多个查询条件。
1. 单个查询条件，单不是唯一索引。

例如 ：`select * from t where id = 10 for update`，如果此表只有 id 加索引，则不会产生间隙锁。如果 id 没有加索引或者加了索引，但是还有其它列也有索引，则会产生间隙锁。

#### 间隙锁的范围
根据检索条件向下寻找最靠近检索条件的记录值 A 作为左区间，向上寻找最靠近检索条件的记录值B作为右区间，即锁定的间隙为（A，B）。

假设一张表的 `number` 字段值有：1、2、3、4、5、6、7、8、9、10、11、12。当执行查询 `select * from t where number = 6` 时，间隙锁锁定的间隙为（5，11），你再想插入 5 到 11 之间的数就会被阻塞。

当你再执行 `update t set number = 6 where id = 1` 也会被阻塞。这是为什么？你想想看，要保证每次查询 number = 6 的数据行数不变，如果你将另外一条数据修改成了 6，岂不会多了一条？所以此时不会允许任何一条数据被修改成 6。

## 使用场景

## 死锁判定
死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。

产生原因：
1. 当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。
1. 锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。

死锁影响：
1. 死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。
1. 在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。
1. 有时当发生死锁时，禁用死锁检测（使用 `innodb_deadlock_detect` 配置选项）可能会更有效，这时可以依赖 `innodb_lock_wait_timeout` 设置进行事务回滚。

死锁检测：
1. 发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。
1. 但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁，这需要通过设置锁等待超时参数 `innodb_lock_wait_timeout` 来解决。

死锁恢复：
1. 死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁。
1. InnoDB 目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。
1. 所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。

MyISAM 避免死锁：
1. 在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。


InnoDB 避免死锁：
1. 为了在单个 InnoDB 表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用 `SELECT ... FOR UPDATE` 语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。
1. 在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁。
1. 如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。
1. 通过 `SELECT ... LOCK IN SHARE MODE` 获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。
1. 改变事务隔离级别。

如果出现死锁，可以用 `SHOW INNODB STATUS` 命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。

## 实现原理

## 锁的操作
#### 加锁
`LOCK TABLES` 用于锁定数据表，避免在备份过程中，表被更新。

```sql
-- 添加一个读锁
LOCK TABLES biz_user READ;

-- 添加一个写锁
LOCK TABLES biz_user WRITE;
```

#### 解锁
1. 使用 `UNLOCK TABLES` 解锁。
1. 使用 `SHOW PROCESSLIST` 找出锁进程 `KILL` 掉。

#### 行锁分析
```sql
SHOW STATUS LIKE 'innodb_row_lock%';

Variable_name                       Value
Innodb_row_lock_current_waits       0
Innodb_row_lock_time                257841
Innodb_row_lock_time_avg            17189
Innodb_row_lock_time_max            31033
Innodb_row_lock_waits               15
```

`Variable_name` 说明：
1. `Innodb_row_lock_current_waits` 当前正在等待锁定的数量。
1. `Innodb_row_lock_time` 从系统启动到现在锁定的时长。
1. `Innodb_row_lock_time_avg` 每次等待锁所花平均时间。
1. `Innodb_row_lock_time_max` 从系统启动到现在锁等待最长的一次所花的时间。
1. `Innodb_row_lock_waits` 系统启动后到现在总共等待锁的次数。

大家可以根据 `Variable_name` 这几个参数考虑是否要进行优化，如果锁定时间，锁定次数过大，那就该考虑优化了。优化手段可以参考之前索引优化的文章。


## MVCC 机制
1. 定义
   MVCC 是一种并发控制机制，在数据库中用来控制并发执行的事务，控制事务隔离进行。

1. 核心思想
   MVCC 是通过保存数据在某个时间点的快照来进行控制的。使用MVCC就是允许同一个数据记录拥有多个不同的版本。然后在查询时通过添加相对应的约束条件，就可以获取用户想要的对应版本的数据。

1. 解决什么
   MVCC 主要是为了提供并发的读写性能，不用加锁就能让多个事务并发读写。在读多写少的场景中，读写不冲突是非常重要的，极大的增加了系统的并发性能。

1. 适用条件
   MVCC 只适用于 MySQL 隔离级别中的读已提交和可重复读。

#### 隐藏列
在 Innodb 中，每一行记录都有两个隐藏列：DATA_ITR_ID、DATA_ROLL_PTR。

1. DATA_TRX_ID
   记录最近更新这条行记录的事务 ID，大小为 6 个字节。

1. DATA_ROLL_PTR
   表示指向该行回滚段的指针，大小为 7 个字节，InnoDB 便是通过这个指针找到之前版本的数据。该行记录上所有旧版本，在 undo 中都通过链表的形式组织。

1. DB_ROW_ID
   行标识（隐藏单调自增 ID），大小为 6 字节，如果表没有主键，InnoDB 会自动生成一个隐藏主键，因此会出现这个列。另外，每条记录的头信息里都有一个专门的 bit 来表示当前记录是否已经被删除。

![](https://pic2.zhimg.com/80/v2-f25ed246387e60fbeb5b7ec9ed9028b1_720w.jpg)

#### undo log
记录数据各版本修改历史即事务链。在多个事务并行操作某行数据的情况下，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针组织成一条 undo Log 链。

![](https://pic4.zhimg.com/80/v2-759e2202ee64b45fb4bc8cdea640c813_720w.jpg)

#### readview
即读视图，用于判断哪些版本对当前事务可见。它由最小事务 Id，未提交事务 Id 数组，最大事务 Id 组成。例如：100|[105, 108, 200]|200。

对于当前事务来说，这些事务都是可见的：
1. 事务 Id 等于当前事务 Id。
1. 事务 Id 不在未提交的事务数组中。

如果当前事务多次查询记录，而期间记录由事务提交了，则不同行为的 readview 查询的结果也不一样。
1. 读未提交情况下，记录的事务提交了，readview 重新获取。则当前事务读取到了提交的事务记录。
1. 读已提交情况下，记录的事务提交了，readview 沿用旧的。则当前事务无法读取到了提交的事务记录。

#### 举例说明
1. 事务 1 插入了数据 {id=101, age = 11, trx_id = 1}。
1. 事务 2 修改了数据 {id=101, age = 12, trx_id = 2}。事务 A 的数据转移到 undo log 里，事务 B 的数据执向 事务 A 的数据。
1. 事务 2 提交了数据。
1. 事务 3 修改了数据 {id=101, age = 13, trx_id = 3}。事务 B 的数据转移到 undo log 里，事务 C 的数据执向 事务 B 的数据。
1. 事务 4 修改了数据 {id=101, age = 14, trx_id = 4}。事务 C 的数据转移到 undo log 里，事务 D 的数据执向 事务 C 的数据。
1. 事务 1 查看了数据，根据 readview {1, 3, 4} 规则，在 undo log 里面找到了 {id=101, age = 11, trx_id = 1}。
1. 事务 5 查看了数据，根据 readview {1, 3, 4} 规则，在 undo log 里面找到了 {id=101, age = 13, trx_id = 2}。
1. 事务 3 提交了数据。
1. 事务 5 查看了数据，读未提交隔离级别，review {1, 4} 变化，在 undo log 里面找到了 {id=101, age = 13, trx_id = 3}。
1. 事务 5 查看了数据，读已提交隔离级别，review {1, 3, 4} 不变，在 undo log 里面找到了 {id=101, age = 13, trx_id = 2}。

## 锁
1. 什么是锁
1. 有哪几种锁
1. 乐观锁和悲观锁、行锁与表锁、共享锁与排他锁
1. 死锁判定原理和具体场景
1. 数据库索引，表锁；乐观锁；悲观锁
1. 乐观锁与悲观锁的使用场景
1. 谈谈数据库乐观锁与悲观锁?
1. MySQL 如何在RR隔离级别下避免幻读问题
1. 乐观锁和悲观锁、行锁与表锁、共享锁与排他锁（inndob如何手动加共享锁与排他锁）
1. 死锁判定原理和具体场景
1. MySQL存储引擎
1. MySQL的表锁&行锁&乐观锁&悲观锁,各自的使用场景
1. MySQL数据库对应的行锁、表锁、悲观锁、乐观锁的区别
1. 数据库锁是怎么实现的
1. 数据库的锁（行锁，表锁，页级锁，意向锁，读锁，写锁，悲观锁，乐观锁，以及加锁的select sql方式）