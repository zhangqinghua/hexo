---
title: MySQL 索引

categories:
- MySQL 指南

date: 2020-04-28 00:00:51

mathjax: true
---
索引是用来快速检索出具有特定值的记录。MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。

## 索引的作用

## 索引的特征
索引有两个特征，即唯一性索引和复合索引。

## 索引的类型
MySQL 目前主要有以下几种索引类型：

1. 普通索引
    最基本的索引，它没有任何限制。普通索引的唯一任务是加快对数据的访问速度。

1. 唯一索引
    它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
    
    事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。

1. 主键索引
    是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。主键索引与唯一索引的唯一区别是：前者在定义时使用的关键字是 PRIMARY 而不是 UNIQUE。 

1. 外键索引 
    如果为某个外键字段定义了一个外键约束条件，MySQL就会定义一个内部索引来帮助自己以最有效率的方式去管理和使用外键约束条件。 

1. 组合索引
    指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀原则。

1. 全文索引
    通过数值比较、范围过滤等就可以完成绝大多数我们需要的查询，但是，如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。

    你可能会说，用 like + % 就可以实现模糊匹配了，为什么还要全文索引？like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。

    你可能没有注意过全文索引，不过至少应该对一种全文索引技术比较熟悉：各种的搜索引擎。虽然搜索引擎的索引对象是超大量的数据，并且通常其背后都不是关系型数据库，不过全文索引的基本原理是一样的。



## 采用查找算法
#### Hash 散列法 
哈希算法（也称散列），就是把任意长度值（key）通过散列算法变换成固定长度的 key 地址，通过这个地址进行访问的数据结构。它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

哈希的时间复杂度是 $O(1)$。

哈希的不足是：1 不支持范围查询，2 不支持排序。

![](http://5b0988e595225.cdn.sohucs.com/images/20190108/90b457d976614a65826199b1f41f3d28.gif)

#### 二叉树
真实的数据存于叶子节点；非叶子节点存储指引搜索方向的数据项。

二叉树支持范围查询。

不足的地方是，根据我们插入的顺序，极端不平衡。

![](http://www.cxyxiaowu.com/wp-content/uploads/2019/10/1571058094-fa3f978179e2c46.jpeg)

#### 红黑树
红黑树是平衡二叉树的一种，解决了插入顺序不平衡的问题。但是也只是相对的减少不平衡，还是会往右边倾斜。

![](https://img.jbzj.com/file_images/article/201901/2019110153603213.gif?2019010153616)

#### BTree
真实的数据存于叶子节点；非叶子节点存储指引搜索方向的数据项。

![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5tcC5zb2h1LmNvbS91cGxvYWQvMjAxNzA3MTMvM2JkMmI0MjIwYTBmNGQxODg3ZTI5NDNhNzI5YzQwYTFfdGgucG5n?x-oss-process=image/format,png)

> B-树、B树和B-tree是同一个数据结构，只不过英语翻译过来之后，有些人误解了以为是多种树。所以好多讲解树的数据结构的博客完全是误导初学者。。。请读者认真分辨。

## 算法对比
|算法名称|时间复杂度|支持范围查询|备注|
| :-- | :-- | :-- | :-- |
|暴力遍历|$O(n^2)$|不支持||
|哈希|$O(1)$|不支持||
|二叉树|$O(n)$|支持|不平衡，时间复杂度就是树的深度|
|红黑树||支持|不平衡|
|B-Tree||支持||
|B+Tree||支持||





## 为什么要用索引，以及索引的原理
首先我们看下在没有索引的情况下是怎么查找数据的：

## 为什么要用B+树


## 最左前缀原则


其实建索引的原理就是将磁盘I/O操作的最小化，不在磁盘中排序，而是在内存中排好序，通过排序的规则去指定磁盘读取就行，也不需要在磁盘上随机读取。


当一个表中有100万数据，而经常用到的数据只有40万或40万以下，是不用考虑建立索引的，没什么性能提升。


使用count统计数据量的时候建议使用count(*)而不是count(列)，因为count(*)MySQL是做了优化的。

什么时候开MySQL的查询缓存，交易系统（写多、读少）、SQL优化测试，建议关闭查询缓存，论坛文章类系统（写少、读多），建议开启查询缓存。

21. 复杂SQL语句优化的思路：



1）首先考虑在一个表中能不能取到有关的信息，尽量少关联表
2）关联条件争取都走主键或外键查询条件，能走到对应的索引
3）争取在满足业务上走小集合数据查找
4）INNER JOIN 和子查询哪个更快，场景不一致速度也不同

where条件多条件一定要按照小结果集排大结果集前面

## 索引的原理
索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小节，然后找到页数。相似的例子还有：查字典，查火车车次，飞机航班等

> 本质都是：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。

## 索引的数据结构
#### 树
树状图是一种数据结构，它是由 n（n >= 1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

它具有以下的特点：
1. 每个结点有零个或多个子结点

1. 没有父结点的结点称为根结点

1. 每一个非根结点有且只有一个父结点

1. 除了根结点外，每个子结点可以分为多个不相交的子树

在下图中：
1. 根节点：A

1. 父节点：A 是 B、C 的父节点

1. 叶子节点：D、E 是叶子节点

1. 深度：树的深度/高度是 3

![](https://img2018.cnblogs.com/blog/827651/201812/827651-20181217164400401-478241633.png)

#### B+ 树
B+ 树是通过二叉查找树，再由平衡二叉树，B 树演化而来。

![](https://img2018.cnblogs.com/blog/827651/201812/827651-20181220151345766-1557776352.png)

B+ 树性质
1. 索引字段要尽量的小
    通过上面的分析，我们知道 I/O 次数取决于 B+ 树的高度 $h$，假设当前数据表的数据为 $n$，每个磁盘块的数据项的数量是 $m$，则有 $h=㏒_(m+1)n$，当数据量 $n$ 一定的情况下，$m$ 越大，$h$ 越小；而 $m = \frac {磁盘块的大小}{数据项的大小}$，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如 **int** 占 4 字节，要比 **bigint** 8 字节少一半。这也是为什么 B+ 树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于 1 时将会退化成线性表。

1. 索引的最左匹配特性
    当 B+ 树的数据项是复合的数据结构，比如（**name**, **age**, **sex**）的时候，B+ 数是按照从左到右的顺序来建立搜索树的。当（**张三**, **20**, **F**）这样的数据来检索的时候，B+ 树会优先比较 **name** 来确定下一步的所搜方向，如果 **name** 相同再依次比较 **age** 和 **sex**，最后得到检索的数据；但当（**20**,**F**）这样的没有 **name** 的数据来的时候，B+ 树就不知道下一步该查哪个节点，因为建立搜索树的时候 **name** 就是第一个比较因子，必须要先根据 **name** 来搜索才能知道下一步去哪里查询。比如当（**张三**,**F**）这样的数据来检索时，B+ 树可以用 **name** 来指定搜索方向，但下一个字段 **age** 的缺失，所以只能把名字等于**张三**的数据都找到，然后再匹配性别是 **F** 的数据了， 这个是非常重要的性质，即索引的最左匹配特性。把名字等于**张三**的数据都找到，然后再匹配性别是 **F** 的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

## 聚合索引与辅助索引
在数据库中，B+ 树的高度一般都在 2~4 层，这也就是说查找某一个键值的行记录时最多只需要 2 到 4 次 IO，这倒不错。因为当前一般的机械硬盘每秒至少可以做 100 次 IO，2~4 次的 IO 意味着查询时间只需要 0.02~0.04 秒。

数据库中的 B+ 树索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。

聚集索引与辅助索引相同的是：不管是聚集索引还是辅助索引，其内部都是 B+ 树的形式，即高度是平衡的，叶子结点存放着所有的数据。

聚集索引与辅助索引不同的是：叶子结点存放的是否是一整行的信息。

#### 聚集索引
InnoDB 存储引擎表是索引组织表，即表中数据按照主键顺序存放。

而聚集索引就是按照每张表的主键构造一棵 B+ 树，同时叶子结点存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。

聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同 B+ 树数据结构一样，每个数据页都通过一个双向链表来进行链接。

如果未定义主键，MySQL 取第一个唯一索引而且只含非空列作为主键，InnoDB 使用它作为聚簇索引。如果没有这样的列，InnoDB 就自己产生一个这样的 Id 值，它有六个字节，而且是隐藏的，使其作为聚簇索引。

由于实际的数据页只能按照一棵 B+ 树进行排序，因此每张表只能拥有一个聚集索引。在多数情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。此外由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值得查询。

聚集索引的好处之一：它对主键的排序查找和范围查找速度非常快，叶子节点的数据就是用户所要查询的数据。如用户需要查找一张表，查询最后的 10 位用户信息，由于 B+ 树索引是双向链表，所以用户可以快速找到最后一个数据页，并取出 10 条记录。

聚集索引的好处之二：范围查询（range query），即如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可。

#### 辅助索引
表中除了聚集索引外其他索引都是辅助索引（Secondary Index，也称为非聚集索引），与聚集索引的区别是：辅助索引的叶子节点不包含行记录的全部数据。

叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含一个书签（bookmark）。该书签用来告诉 InnoDB 存储引擎去哪里可以找到与索引相对应的行数据。

由于 InnoDB 存储引擎是索引组织表，因此 InnoDB 存储引擎的辅助索引的书签就是相应行数据的聚集索引键。

辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引，但只能有一个聚集索引。当通过辅助索引来寻找数据时，InnoDB 存储引擎会遍历辅助索引并通过叶子级别的指针获得只想主键索引的主键，然后再通过主键索引来找到一个完整的行记录。

举例来说，如果在一棵高度为 3 的辅助索引树种查找数据，那需要对这个辅助索引树遍历 3 次找到指定主键，如果聚集索引树的高度同样为 3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在的页，因此一共需要 6 次逻辑 IO 访问才能得到最终的一个数据页。

## 索引算法
我们可以在创建上述索引的时候，为其指定索引类型，分两类
- Hash：查询单条快，范围查询慢
- BTree：B+ 树，层数越多，数据量指数级增长（默认）


## 索引命中
并不是说我们创建了索引就一定会加快查询速度，若想利用索引达到预想的提高查询速度的效果，我们在添加索引时，必须遵循以下问题：
1. 范围问题，或者说条件不明确

1. 

## 联合索引和覆盖索引
#### 联合索引
联合索引是指对表上的多个列合起来做一个索引。联合索引的创建方法与单个索引的创建方法一样，不同之处仅在于有多个索引列。

那么何时需要使用联合索引呢？在讨论这个问题之前，先来看一下联合索引内部的结果。从本质上来说，联合索引就是一棵 B+ 树，不同的是联合索引的键值得数量不是 1，而是 >=2。接着来讨论两个整型列组成的联合索引，假定两个键值得名称分别为 a、b 如图：

![](https://images2018.cnblogs.com/blog/1036857/201711/1036857-20171126004856453-1491949427.png)

可以看到这与我们之前看到的单个键的 B+ 树并没有什么不同，键值都是排序的，通过叶子结点可以逻辑上顺序地读出所有数据，就上面的例子来说，即（1,1），（1,2），（2,1），（2,4），（3,1），（3,2），数据按（a,b）的顺序进行了存放。

因此，对于查询
```sql
select * from table where a = xxx and b = xxx
```

显然是可以使用 (a, b) 这个联合索引的，而对于单个列 a 的查询

```sql
select * from table where a = xxx
```

也是可以使用（a, b）这个索引的。

但对于 b 列的查询
```sql
select * from table where b = xxx,
```
则不可以使用（a,b） 索引，其实你不难发现原因，叶子节点上b的值为 1、2、1、4、1、2 显然不是排序的，因此对于 b 列的查询使用不到 (a,b) 索引。

联合索引的第二个好处是在第一个键相同的情况下，已经对第二个键进行了排序处理，例如在很多情况下应用程序都需要查询某个用户的购物情况，并按照时间进行排序，最后取出最近三次的购买记录，这时使用联合索引可以帮我们避免多一次的排序操作，因为索引本身在叶子节点已经排序了。

#### 覆盖索引
InnoDB 存储引擎支持覆盖索引（covering index，或称索引覆盖），即从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。

使用覆盖索引的一个好处是：辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的 IO 操作。

> 注意：覆盖索引技术最早是在 InnoDB Plugin 中完成并实现，这意味着对于 InnoD B版本小于 1.0 的，或者 MySQL 数据库版本为 5.0 以下的，InnoDB 存储引擎不支持覆盖索引特性。

![](http://assets.processon.com/chart_image/5ed3cfc55653bb073440bcd1.png?_=1590939667033)



#### 创建索引
```sql
-- 单列索引
CREATE INDEX index_name ON table_name (column_name);

-- 唯一索引
CREATE UNIQUE INDEX index_name on table_name (column_name);

-- 联合索引
CREATE INDEX index_name on table_name (column1, column2);

-- 全文索引
CREATE TABLE table_name (
    id INT(11) NOT NULL AUTO_INCREMENT,
    column1 VARCHAR(255),
    column2 TEXT NOT NULL,

    PRIMARY KEY (id),
    FULLTEXT KEY index_name(column1, column2)  
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

CREATE FULLTEXT INDEX index_name on table_name(column1, column2);

ALTER TABLE table_name ADD FULLTEXT INDEX index_name(column1, column2);
```

#### 修改索引
修改个 O，直接删掉重建。

#### 删除索引
删除索引时应当特别小心，数据库的性能可能会因此而降低或者提高。

```sql
-- 使用 DROP INDEX 命令删除索引
DROP INDEX table_name.index_name;

-- 使用 ALTER 命令删除主键
ALTER TABLE table_name DROP PRIMARY KEY;

-- 使用 ALTER 命令删除索引
ALTER TABLE table_name DROP INDEX index_name;
```

#### 显示索引信息
你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 **\G** 来格式化输出信息。
```sql
SHOW INDEX FROM table_name;
```