---
title: 数据库优化

categories:
- 数据库

date: 2018-03-27 04:00:00
---

数据库笔记

# 表结构的设计

1. 字段少一些

1. 字段的长度尽可能的设得短一些
    可以提高查询效率，建立索引也可以减少资源消耗。

1. 尽量选择数字类型而不用字符串类型（电话号码）
    这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接回逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

1. 灵活选择`char`和`varchar`
    不可变字符类型`char`查询快，耗存储空间，varchar查询相对较慢，但节省空间。在设计时用户名、密码等 长度变化不大的字段可以选择 `char`，对于评论等长度变化大的字段可以选择`varchar`。

1. 数据行的长度不要超过8020字节
    如果超过这个长度的话在物理页中这条数据会占用两行从而造成存储碎片，降低查询效率。

# 查询的优化

1. 减少对数据库的访问次数

1. 减少查询字段

1. 减少结果集，通过条件查询尽量少的行

1. 能够分开的操作尽量分开处理，提高每次的响应速度

1. 使用的索引查询（没有索引会全表查询）

1. 减少全表查询
    尽量使语句符合查询优化器的规则避免全表扫描而使用索引查询。
    ```sql
    select * from table1 where name='zhangsan' and tID > 10000 
    select * from table1 where tID > 10000 and name='zhangsan'
    ```

1. 避免在 where 子句中对字段进行 null 值判断
    否则将导致引擎放弃使用索引而进行全表扫描
    ```sql
    select id from t where num is null 
    ```
    可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：
    ```sql
    select id from t where num=0
    ```
1. 尽量避免在`where`子句中使用`or`来连接条件
    否则将导致引擎放弃使用索引而进行全表扫描
    ```sql
    select id from t where num=10 or num=20
    ```
    可以这样查询：
    ```sql
    select id from t where num=10 union all  select id from t where num=20
    ```

1. `in`和`not in`也要慎用
    因为`in`会使系统无法使用索引,而只能直接搜索表中的数据。如：
    ```sql
    select id from t where num in(1,2,3)
    ```
    对于连续的数值，能用`between`就不要用`in`了：
    ```sql
    select id from t where num between 1 and 3
    ```
1. 尽量避免在索引过的字符数据中，使用非打头字母搜索。这也使得引擎无法利用索引。
    ```sql
    Select * FROM T1 Where NAME LIKE `%L%`
    Select * FROM T1 Where SUBSTING(NAME,2,1)=`L`
    Select * FROM T1 Where NAME LIKE `L%`
    ```
    即使NAME字段建有索引，前两个查询依然无法利用索引完成加快操作，引擎不得不对全表所有数据逐条操作来完成任务。而第三个查询能够使用索引来加快操作。

1. 必要时强制查询优化器使用某个索引
    如在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：可以改为强制查询使用索引：
    ```sql
    select id from t with(index(索引名)) where num=@num
    ```

1. 应尽量避免在`where`子句中对字段进行表达式操作
    这将导致引擎放弃使用索引而进行全表扫描。如：
    ```sql
    Select * FROM T1 Where F1/2=100 
    # 应改为
    Select * FROM T1 Where F1=100*2 

    Select * FROM RECORD Where SUBSTRING(CARD_NO,1,4)='5378'
    # 应改为
    Select * FROM RECORD Where CARD_NO LIKE '5378%'

    Select member_number, first_name, last_name FROM members Where DATEDIFF(yy,datofbirth,GETDATE()) > 21
    # 应改为
    Select member_number, first_name, last_name FROM members Where dateofbirth <DATEADD(yy,-21,GETDATE())
    ```
    即：任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。

1. 应尽量避免在where子句中对字段进行函数操作
    这将导致引擎放弃使用索引而进行全表扫描。如：
    ```sql
    select id from t where substring(name,1,3)='abc' --name以abc开头的id
    select id from t where name like 'abc%'

    select id from t where datediff(day,createdate,'2005-11-30')=0 --‘2005-11-30’生成的id
    select id from t where createdate>='2005-11-30' and createdate<'2005-12-1'
    ```

1. 不要在`where`子句中的`=`左边进行函数、算术运算或其他表达式运算
    否则系统将可能无法正确使用索引。

1. 很多时候用`exists`是一个好的选择
    ```sql
    select num from a where num in(select num from b)

    -- 用下面的语句替换
    select num from a where exists(select 1 from b where num=a.num)
    select SUM(T1.C1)FROM T1 Where((Select COUNT(*)FROM T2 Where T2.C2=T1.C2>0)
    select SUM(T1.C1) FROM T1Where EXISTS( Select * FROM T2 Where T2.C2=T1.C2)
    ```
    两者产生相同的结果，但是后者的效率显然要高于前者。因为后者不会产生大量锁定的表扫描或是索引扫描。

    如果你想校验表里是否存在某条纪录，不要用count(*)那样效率很低，而且浪费服务器资源。可以用`EXISTS`代替。如：
    ```sql
    IF (Select COUNT(*) FROM table_name Where column_name = 'xxx')
    -- 可以写成
    IF EXISTS (Select * FROM table_name Where column_name = 'xxx')
    ```

    经常需要写一个T_SQL语句比较一个父结果集和子结果集，从而找到是否存在在父结果集中有而在子结果集中没有的记录，如：
    ```sql
    Select a.hdr_key FROM hdr_tbl a Where NOT EXISTS (Select * FROM dtl_tbl b Where a.hdr_key = b.hdr_key)  -- tbl a 表示tbl用别名a代替

    Select a.hdr_key FROM hdr_tbl a  LEFT JOIN dtl_tbl b ON a.hdr_key = b.hdr_key Where b.hdr_key IS NULL

    Select hdr_key FROM hdr_tbl  Where hdr_key NOT IN (Select hdr_key FROM dtl_tbl)
    ```
    三种写法都可以得到同样正确的结果，但是效率依次降低。

1. 尽量使用表变量来代替临时表
    如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。

1. 避免频繁创建和删除临时表，以减少系统表资源的消耗。

1. 尽量避免大事务操作，提高系统并发能力

1. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理

1. 避免使用不兼容的数据类型。

1. 充分利用连接条件
    在某种情况下，两个表之间可能不只一个的连接条件，这时在`Where`子句中将连接条件完整的写上，有可能大大提高查询速度。
    ```sql
    Select SUM(A.AMOUNT) FROM ACCOUNT A,CARD B Where A.CARD_NO = B.CARD_NO
    -- 第二句将比第一句执行快得多
    Select SUM(A.AMOUNT) FROM ACCOUNT A,CARD B Where A.CARD_NO = B.CARD_NO AND A.ACCOUNT_NO=B.ACCOUNT_NO 
    ```

1. 使用视图加速查询
    把表的一个子集进行排序并创建视图，有时能加速查询。它有助于避免多重排序 操作，而且在其他方面还能简化优化器的工作。

1. 能用`DISTINCT`的就不用`GROUP BY`
    ```sql
    Select orderID FROM Details Where UnitPrice > 10 GROUP BY orderID
    -- 可改为
    Select DISTINCT orderID FROM Details Where UnitPrice > 10
    ```

1. 能用`UNION ALL`就不要用`UNION`
    `UNION ALL`不执行`Select DISTINCT`函数，这样就会减少很多不必要的资源

1. 尽量不要用Select INTO语句
    Select into 语句会导致表锁定，阻止其他用户访问该表。

# 建立存储过程

# 拆分表

目前很多互联网系统都存在单表数据量过大的问题，这就降低了查询速度，影响了客户体验。为了提高查询速度，我们可以优化sql语句，优化表结构和索引，不过对那些百万级千万级的数据库表，即便是优化过后，查询速度还是满足不了要求。这时候我们就可以通过分表降低单次查询数据量，从而提高查询速度，一般分表的方式有两种：水平拆分和垂直拆分，两者各有利弊，适用于不同的情况。

## 水平拆分

水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。

通常情况下，我们使用取模的方式来进行表的拆分;比如一张有400W的用户表users，为提高其查询效率我们把其分成4张表users1，users2，users3，users4 
通过用ID取模的方法把数据分散到四张表内Id%4+1 = [1,2,3,4]
然后查询,更新,删除也是通过取模的方法来查询。

水平拆分的优点：
◆表关联基本能够在数据库端全部完成；
◆不会存在某些超大型数据量和高负载的表遇到瓶颈的问题；
◆应用程序端整体架构改动相对较少；
◆事务处理相对简单；
◆只要切分规则能够定义好，基本上较难遇到扩展性限制；

水平切分的缺点：
◆切分规则相对更为复杂，很难抽象出一个能够满足整个数据库的切分规则；
◆后期数据的维护难度有所增加，人为手工定位数据更困难；
◆应用系统各模块耦合度较高，可能会对后面数据的迁移拆分造成一定的困难。

## 垂直拆分

垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。表的记录并不多，但是字段却很长，表占用空间很大，检索表的时候需要执行大量的IO，严重降低了性能。这时需要把大的字段拆分到另一个表，并且该表与原表是一对一的关系。

通常我们按以下原则进行垂直拆分:
1，把不常用的字段单独放在一张表;
2，把text，blob等大字段拆分出来放在附表中;
3，经常组合查询的列放在一张表中;

垂直切分的优点 
◆ 数据库的拆分简单明了，拆分规则明确； 
◆ 应用程序模块清晰明确，整合容易； 
◆ 数据维护方便易行，容易定位；

垂直切分的缺点 
◆ 部分表关联无法在数据库级别完成，需要在程序中完成； 
◆ 对于访问极其频繁且数据量超大的表仍然存在性能平静，不一定能满足要求； 
◆ 事务处理相对更为复杂； 
◆ 切分达到一定程度之后，扩展性会遇到限制； 
◆ 过读切分可能会带来系统过渡复杂而难以维护。

# 拆分库

# 主从复制

1. MYSQL主从复制是个异步过程，有毫秒时间差
1. Master需要开启BIN-LOG功能
    bin-log文件用于记录数据库增删修改，它除了用于主从还可以用于备份恢复
1. 需要开启3个线程，Master IO线程，Slave IO线程，SQL线程
1. Slave start后，通过IO线程连接Master请求某个BIN-LOG，Position
1. Master收到请求后，IO线程将BIN-LOG，Position返回给Slave
1. Slave收到bin-log日志
    - 将bin-log写入relay-log中继日志
    - 创建一个Master.info文件，
        - 记录Master IP
        - 用户名密码，Master Bin-log名称
        - Position位置
1. Slave开启SQL线程，实时监控中中继日志是否有更新
    如果有更新则解析文件中SQL代码，在Slave数据库执行

LAP + MYSQL 主从

1. 主Mysql宕机后自动切换
    - MHA
    - Keppalive
    - shell

![主从复制](001.png)

# 读写分离

让Master数据库处理增删改操作，而让Slave数据库处理Select操作。

1. Mysql-Proxy实现读写分离
1. Amoeba读写分离
1. Mycat读写分离
1. 基于程序写，改源码

![读写分离](002.png)

## Mysql-Proxy

是Mysql官方提供的中间件服务，允许用户指定Lua脚本对SQL请求进行拦截，对请求进行分析于修改。

Sql请求一般分为读请求与写请求，基于Lua脚本可以实现将SQL读请求转发至Slave服务器。

1. 在一台服务器安装Mysql-Proxy，将sql请求指向此服务器，默认4041端口
1. 下载
1. 解压（不需要编译）
1. `vim /etc/profile`配置环境变量`bin`目录
1. `mysql-proxy`运行
1. 写读写分离脚本