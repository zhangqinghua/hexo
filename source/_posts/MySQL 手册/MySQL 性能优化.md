---
title: MySQL 性能优化

categories:
- MySQL 手册

date: 2020-07-07 00:00:00
---
## 优化的目标
1. QPS
1. TPS
1. 吞吐量
1. 响应时间
1. 减少 IO 次数 
    IO 永远是数据库最容易瓶颈的地方，大部分数据库操作中超过90%的时间都是 IO 操作所占用的，减少 IO 次数是SQL 优化中需要第一优先考虑，当然，也是收效最明显的优化手段。
1. 降低 CPU 计算 
    除了 IO 瓶颈之外，SQL优化中需要考虑的就是 CPU 运算量的优化了。order by, group by,distinct … 都是消耗 CPU 的大户（这些操作基本上都是 CPU 处理内存中的数据比较运算）。当我们的 IO 优化做到一定阶段之后，降低 CPU 计算也就成为了我们 SQL 优化的重要目标

## 优化的原则
数据库优化可以分成 4 个方面来讲：
1. SQL 语句和索引的优化
1. 数据表的优化
1. 系统配置的优化
1. 硬件的优化

其中，数据结构、SQL、索引是成本最低，且效果最好的优化手段。而硬件的优化则成本比较高。

![](https://p1htmlkernalweb.mybluemix.net/image/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzg0OTAxNzMvYXJ0aWNsZS9kZXRhaWxzLzEwNDk5NzUwMQ==_aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuLzIwMjAwMzIwMjAwNDM2NjY3LnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3dhdGVybWFyayx0eXBlX1ptRnVaM3BvWlc1bmFHVnBkR2ssc2hhZG93XzEwLHRleHRfYUhSMGNITTZMeTlpYkc5bkxtTnpaRzR1Ym1WMEwzRnhYek00TkRrd01UY3osc2l6ZV8xNixjb2xvcl9GRkZGRkYsdF83MA==)

漏斗法则优化法可以归纳为5个层次：
1. 减少数据访问（减少磁盘访问）
2. 返回更少数据（减少网络传输或磁盘访问）
3. 减少交互次数（减少网络传输）
4. 减少服务器 CPU 开销（减少 CPU 及内存开销）
5. 利用更多资源（增加资源）

由于每一层优化法则都是解决其对应硬件的性能问题，所以带来的性能提升比例也不一样。传统数据库系统设计是也是尽可能对低速设备提供优化方法，因此针对低速设备问题的可优化手段也更多，优化成本也更低。

我们任何一个SQL的性能优化都应该按这个规则由上到下来诊断问题并提出解决方案，而不应该首先想到的是增加资源解决问题。

以下是每个优化法则层级对应优化效果及成本经验参考：

|优化法则|性能提升效果|优化成本|
| :- |
|减少数据访问|1~1000|低|
|返回更少数据|1~100|低|
|减少交互次数|1~20|低|
|减少服务器 CPU 开销|1~5|低|
|利用更多资源|@~10|高|

![](http://img.shangdixinxi.com/up/info/202006/20200607132814970915.png)

![](https://ucc.alicdn.com/pic/developer-ecology/76f2a3150468463ea197396326949fb0.png)


#### 软件层面
数据结构、SQL、索引是成本最低，且效果最好的优化手段。

## 配置层面

## 架构层面

https://www.cnblogs.com/claireyuancy/p/7258314.html


## 数据库优化
#### 存储引擎


## 表结构优化
#### 数据类型
1. 数字类型
    能确定不会使用负数的字段，建议添加 `unsigned` 定义。

    合理使用 `tinyint`、`int`、`bigint`。因为三者所占用的存储空间也有很大的差别。

    不要使用 `double`，不仅仅只是存储长度的问题，同时还会存在精确性的问题。
    
    固定精度的小数，也不建议使用 `decimal`，建议乘以固定倍数转换成整数存储，可以大大节省存储空间，且不会带来任何附加维护成本。

1. 字符类型
    非万不得已不要使用 `text` 数据类型，其处理方式决定了他的性能要低于 `char` 或者是 `varchar` 类型的处理。

    定长字段，建议使用 `char` 类型，不定长字段尽量使用 `varchar`，且仅仅设定适当的最大长度，而不是非常随意的给一个很大的最大长度限定，因为不同的长度范围，MySQL 也会有不一样的存储处理。

    对于状态字段，以尝试使用 `enum` 来存放，因为可以极大的降低存储空间。
    
    如果是存放可预先定义的属性数据呢？可以尝试使用 `set` 类型，即使存在多种属性，同样可以游刃有余，同时还可以节省不小的存储空间。
    
    尽量避免在数据库中存储二进制数据。可以采用第三方的对象存储服务。

1. 时间类型
    不建议通过 `int` 类型类存储一个 Unix 时间戳的值，因为这太不直观，会给维护带来不必要的麻烦，同时还不会带来任何好处。
    
    尽量使用 `timestamp` 类型，因为其存储空间只需要 `datetime` 类型的一半。
    
    对于只需要精确到某一天的数据类型，建议使用 `date` 类型，因为他的存储空间只需要 3个字节，比 `timestamp` 还少。

1. 字符编码
    建议统一使用 utf8mb4 字符编码，兼容绝大多数文字和表情。

#### 精简字段
对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。

如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。

当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看Slashdot的例子（2009年11月06日），一个简单的ALTER TABLE语句花了3个多小时，因为里面有一千六百万条数据。

#### 适当拆分
将表中大部分访问都不需要用到的字段，和类似于 `text` 或者是很大的 `varchar` 类型的大字段，拆分到另外的独立表中。以减少常用数据所占用的存储空间，每个数据块中可以存储的数据条数可以大大增加，既减少物理 IO 次数，也能大大提高内存中的缓存命中率。

#### 垂直分割
“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。（以前，在银行做过项目，见过一张表有100多个字段，很恐怖）

示例一：在Users表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性能。

示例二： 你有一个叫 “last_login” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。

另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。

#### 适度冗余
适当冗余被频繁引用的字段，避免减少联表查询。

#### 避免 null 字段
当字段中存在 `null` 值时会影响索引查询的效率。可以设置为空字符串或 0 代替。

## SQL 优化
#### 优化 SQL 的一般步骤
1. 定位慢 SQL
    通过 `show status` 命令了解各种SQL的执行效率。

1. 定位 SQL 瓶颈
    通过 `explain` 或 `desc` 分析低效SQL的执行计划。

    通过 `show profile` 分析 SQL。

    通过 `trace` 分析优化器如何选择执行计划。

1. 优化 SQL
    运用 SQL 优化原则来优化 SQL。

1. 优先优化高并发的 SQL，而不是执行频率低的某些大 SQL
    对于破坏性来说，高并发的 SQL 总是会比低频率的来得大，因为高并发的 SQL 一旦出现问题，甚至不会给我们任何喘息的机会就会将系统压跨。而对于一些虽然需要消耗大量 IO 而且响应很慢的 SQL，由于频率低，即使遇到，最多就是让整个系统响应慢一点，但至少可能撑一会儿，让我们有缓冲的机会。

    尽可能对每一条运行在数据库中的 SQL 进行 `explain`。

#### SQL 优化原则
1. 避免查询全部字段
    只查必要的字段。如果需要全部字段，避免使用 `select *`，把所有字段名列出来。

1. 避免全盘扫描
    在 `where`，`group by`，`order by`，`on` 等从句涉及到的列上建立索引

    避免在 `where` 子句中使用 `!=` 或 `<>` 操作符，否则将引擎放弃使用索引而进行全表扫描。

    避免在 `where` 子句中对字段进行 `null` 值判断，否则将导致引擎放弃使用索引而进行全表扫描。如有必要可以用 0 代替 `null`。

    避免在 `where` 子句中使用 `or` 来连接条件。如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。

    避免使用前导模糊查询，否则将导致全表扫描。例如 `name like '%c%'` 改成 `name like '%c%'`。

    慎用 `not in`，否则会导致全表扫描。对于连续的数值，能用 `between` 就不要用 `in` 了，尽量使用 `exists` 代替 `in`。

    避免在 `where` 子句中对字段进行表达式与函数或其他表达式运算操作，这将导致引擎放弃使用索引而进行全表扫描。例如 `where num / 2 = 100` 改成 `where num = 100 * 2`。

    使用 `limit` 对查询结果的记录进行限定，单条查询最后添加 `limit 1`，停止全表扫描。

1. 优化子查询
    使用子查询需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。

    用 `join` 代替子查询。虽然 `join` 性能并不佳，但是和 MySQL 的子查询比起来还是有非常大的性能优势。

1. 优化 `join` 查询
    尽量少使用 `join`。

    确认两个表中 `join` 的字段是被建过索引的。这样，MySQ L内部会启动为你优化 `join` 的 SQL 语句的机制。

    确认两个表中 `join` 的字段是相同类型的。例如：如果你要把 `decimal` 字段和一个 `int` 字段 `join` 在一起，MySQL就无法使用它们的索引。对于那些字符类型的字段，还需要有相同的字符集才行（两个表的字符集有可能不一样）。

1. 优化 `rand` 查询
    实现随机选挑一行数据的功能，不建议使用 `rand` 函数，性能很低。可以先统计总行数，然后计算出一个随机数，再使用 `limit` 查询。

    例如 `select id from biz_user order by rand() limit 1` 可以改成 `select id from biz_user limit 100,1`。

1. 优化 `count` 查询
    注意  `count(1)` 和 `count(name)` 的区别。前者统计所有行，后者只统计字段值不为 `null` 的行。

1. 优化 `limit` 查询
    结果只会有一条结果，加上 `limit 1` 可以增加性能。这样一样，MySQL 数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。

1. 优化 `union` 查询
    `union` 需要将两个（或者多个）结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的 CPU 运算，加大资源消耗及延迟。
    
    所以当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候，尽量使用 `union all` 而不是 `union`。

1. 优化 `distinct` 查询
    `distinct` 用于查询某个字段不重复的记录。

    功能优化：因为 `distinct` 只能返回他的目标字段，而无法返回其他字段。如果我们希望返回其目标字段所在的记录，可以使用 `group by` 代替，例如：`select distinct(name) from biz_user` 替换为 `select id, name from biz_user group by name`。 
    
    性能优化：

1. 优化查询缓存
    像 `now()`、 `rand()`、`curdate()` 或是其它的诸如此类的 SQL 函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替 MySQL 的函数，从而开启缓存。

    例如 `where gmtmodify >= now()` 可以改成 `where gmtmodify >= '2020-08-10'`。

1. 尽量少排序
    排序操作会消耗较多的 CPU 资源，所以减少排序可以在缓存命中率高等 IO 能力足够的场景下会较大影响 SQL 的响应时间。
    
    对于 MySQL 来说，减少排序有多种办法，比如：减少参与排序的记录条数，非必要不对数据进行排序。

1. 尽量早过滤
    将过滤性更好的字段放得更靠前。在 SQL 编写中同样可以使用这一原则来优化一些 `join` 的 SQL。比如我们在多个表进行分页数据查询的时候，我们最好是能够在一个表上先过滤好数据分好页，然后再用分好页的结果集与另外的表 `join`，这样可以尽可能多的减少不必要的 IO 操作，大大节省 IO 操作所消耗的时间。

1. 避免类型转换
    这里所说的“类型转换”是指 `where` 子句中出现字段的类型和传入的参数类型不一致的时候发生的类型转换。

1. 避免复杂 SQL
    提升可阅读性；避免慢查询的概率；可以转换成多个短查询，用业务端处理。


查询分析方法
观察，至少跑1天，看看生产的慢SQL情况。

开启慢查询日志，设置阈值，比如超过5秒钟的就是慢SQL，并将它抓取出来。

explain+慢SQL分析

show profile

运维经理 or DBA，进行SQL数据库服务器的参数调优。


in 和 exists
小表驱动大表，即小的数据集驱动大的数据集。

当B表的数据集必须小于A表的数据集时，用in优于exists。

当A表的数据集系小于表的数据集时，用exists优于in。

提高Order By的速度
Order by时select *是一个大忌，只Query需要的字段，这点非常重要。 在这里的影响是:

1.1 当Query的字段大小总和小于max_length_for_sort_data 而且排序字段不是TEXT|BLOB类型时，会用改进后的算法——单路排序，否则用老算法——多路排序。

1.2 两种算法的数据都有可能超出sort_buffer的容量， 超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size 。

尝试提高sort_buffer_size
不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的

尝试提高max_length_for_sort_data
提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率。

Group By
group by实质是先排序后进行分组，遵照索引建的最佳左前缀

当无法使用索引列，增大max_ length_ for_ sort_data参数的设置+增大sort_buffer_size参数的设置

where高于having，能写在where限定的条件就不要去having限定了。




## ??
1. 固定长度的表会更快 
    “static” 或 “fixed-length”


## 硬件层面
1. 使用 IP 而不是域名做数据库路径。避免 DNS 解析
1. 机械硬盘、固态硬盘、内存硬盘

#### 读写分离
一台数据库支持最大连接数是有限的，如果用户的并发访问很多，一台服务器无法满足需求，可以集群处理。MySQL 集群处理技术最常用的就是读写分离。

## 外部优化
1. 代码、业务优化，减少数据查询
1. 缓存如 Redis 等，将热点数据缓存起来
1. 搜索引擎如 solr，elasticsearch

## 问题
1. 
1. MySQL 如何优化 DISTINCT
1. MySQL 数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化
1. 锁的优化策略
1. 什么情况下设置了索引但无法使用
1. SQL注入漏洞产生的原因和如何防止
1. 说说对SQL语句优化有哪些方法？（选择几条）
1. 查询缓慢和解决方式（explain、慢查询日志、show profile等）
1. SQL优化，常用的索引？
1. 数据库性能调优如何做
1. 如何做的 MySQL 优化
1. MySQL 数据库优化会涉及到哪些？
1. 从SQL、JVM、架构、数据库四个方面讲讲优化思路，以及如何优先排序？
1. 四个表 记录成绩，每个大约十万条记录，如何找到成绩最好的同学
1. MySQL的慢 SQL 优化一般如何来做？除此外还有什么方法优化？
1. MySQL如何获取慢SQL，以及慢查询的解决方式
1. 数据库崩溃时事务的恢复机制
1. 在工作中，SQL语句的优化和注意的事项
1. 数据库万级变成亿级，你如何来解决。
1. MySQL数据库引擎？应用场景？查询优化？NoSQL有用或了解吗？
1. Redis 和数据库如何保证数据一致性
1. 谈谈MySQL的查询优化方法，重点谈谈优化步骤。
1. 如何防止sql注入，了解哪些加密算法，rsa过程说下
1. MySQL的常见优化方式、定为慢查询
1. 优化（explain，慢查询，show profile）
1. myisamchk 是用来做什么的