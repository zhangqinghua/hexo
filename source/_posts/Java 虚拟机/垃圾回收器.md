---
title: 垃圾回收器

categories:
- Java Virtual Machine Specification

tags:
- JVM

date: 2020-01-21
---

## JVM的垃圾回收机制

## 名称解释
1. YGC 对新生代堆进行gc。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。
1. FGC 全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。以我们生产环境为例，一般比较少会触发fgc，有时10天或一周左右会有一次。

## 什么时候执行YGC和FGC
a.edn空间不足,执行 young gc
b.old空间不足，perm空间不足，调用方法System.gc() ，ygc时的悲观策略, dump live的内存信息时(jmap –dump:live)，都会执行full gc



## 如何确认垃圾
#### 引用计数法
一个对象如果没有任何与之关联的引用，则说明对象不太可能再被用到，那么这个对象就是可回收对象。这种方式即是引用计数法。

这种方式的问题是无法解决循环引用的问题。

#### 可达性分析
通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。

所谓“GC roots”，或者说 Tracing GC 的“根集合”，就是一组必须活跃的引用。例如说，这些引用可能包括：
1. 所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。
1. VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。
1. JNI handles，包括global handles和local handles（看情况）
1. 所有当前被加载的Java类（看情况）
1. Java类的引用类型静态变量（看情况）
1. Java类的运行时常量池里的引用类型常量（String或Class类型）（看情况）
1. String常量池（StringTable）里的引用

比较常见的将对象视为可回收对象的原因：
1. 显式地将对象的唯一强引用指向新的对象
1. 显式地将对象的唯一强引用赋值为Null
1. 局部引用所指向的对象（如，方法内对象）

## 回收算法

#### 标记-清除算法（Mark-Sweep）
是最基础的垃圾回收算法，分为两个阶段，标记和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。

该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。

![](https://images2015.cnblogs.com/blog/989246/201704/989246-20170406161514082-1220415753.jpg)

#### 复制算法（Copying）
为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。它按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。

这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，复制算法的效率会大大降低。

![](https://images2015.cnblogs.com/blog/989246/201704/989246-20170406162053957-592638524.jpg)

#### 标记-整理算法（Mark-Compact）
结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。

![](https://images2015.cnblogs.com/blog/989246/201704/989246-20170406162848519-1635773526.jpg)

#### 分代收集算法（Generational Collection）
分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老年代（Tenured/Old Generation）和新生代（Young Generation）。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。

目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1:1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间（From Space，To Space），每次使用 Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。

![](https://images2015.cnblogs.com/blog/989246/201704/989246-20170406170311707-1412704605.jpg)

而老生代因为每次只回收少量对象，因而采用 Mark-Compact 算法。

对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space （Survivor 目前存放对象的那一块），少数情况会直接分配到老生代。当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理。如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。当对象在 Survivor 区躲过一次GC后，其年龄就会 +1。默认情况下年龄到达 15 的对象会被移到老生代中。

## 垃圾收集器
垃圾收集算法是垃圾收集器的理论基础，而垃圾收集器就是其具体实现。下面介绍 HotSpot 虚拟机提供的几种垃圾收集器。

#### Serial/Serial Old
最古老的收集器，是一个单线程收集器，用它进行垃圾回收时，必须暂停所有用户线程。Serial 是针对新生代的收集器，采用 Copying 算法；而 Serial Old 是针对老生代的收集器，采用 Mark-Compact 算法。优点是简单高效，缺点是需要暂停用户线程。

#### ParNew
Seral/Serial Old 的多线程版本，使用多个线程进行垃圾收集。

#### Parallel Scavenge
新生代的并行收集器，回收期间不需要暂停其他线程，采用 Copying 算法。该收集器与前两个收集器不同，主要为了达到一个可控的吞吐量。

#### Parallel Old
Parallel Scavenge 的老生代版本，采用 Mark-Compact 算法和多线程。

#### CMS
Current Mark Sweep 收集器是一种以最小回收时间停顿为目标的并发回收器，因而采用 Mark-Sweep 算法。

#### G1
G1（Garbage First）收集器技术的前沿成果，是面向服务端的收集器，能充分利用 CPU 和多核环境。是一款并行与并发收集器，它能够建立可预测的停顿时间模型。

## 内存调优



JVM什么时候会触发YGC，什么时候触发FGC？

JVM如何内存调优、内存泄漏如何排查