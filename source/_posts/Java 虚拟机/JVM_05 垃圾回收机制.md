---
title: JVM_05 垃圾回收机制

categories:
- Java 虚拟机

date: 2020-01-01 00:00:05
---

## JVM的垃圾回收机制

## 名称解释
1. YGC 对新生代堆进行gc。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。
1. FGC 全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。以我们生产环境为例，一般比较少会触发fgc，有时10天或一周左右会有一次。

## 什么时候执行YGC和FGC
a.edn空间不足,执行 young gc
b.old空间不足，perm空间不足，调用方法System.gc() ，ygc时的悲观策略, dump live的内存信息时(jmap –dump:live)，都会执行full gc



## 如何确认垃圾
#### 引用计数法
一个对象如果没有任何与之关联的引用，则说明对象不太可能再被用到，那么这个对象就是可回收对象。这种方式即是引用计数法。

这种方式的问题是无法解决循环引用的问题。

#### 可达性分析
通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。

所谓“GC roots”，或者说 Tracing GC 的“根集合”，就是一组必须活跃的引用。例如说，这些引用可能包括：
1. 所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。
1. VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。
1. JNI handles，包括global handles和local handles（看情况）
1. 所有当前被加载的Java类（看情况）
1. Java类的引用类型静态变量（看情况）
1. Java类的运行时常量池里的引用类型常量（String或Class类型）（看情况）
1. String常量池（StringTable）里的引用

比较常见的将对象视为可回收对象的原因：
1. 显式地将对象的唯一强引用指向新的对象
1. 显式地将对象的唯一强引用赋值为Null
1. 局部引用所指向的对象（如，方法内对象）

## 回收算法

#### 标记-清除算法
首先标记出所有需要回收的对象，使用可达性分析算法判断一个对象是否为可回收，在标记完成后统一回收所有被标记的对象。

![](https://images2015.cnblogs.com/blog/568153/201707/568153-20170713133044525-1749754709.png)

优缺点：
1. 效率问题，标记和清除两个阶段的效率都不高。
1. 空间问题，标记清除后会产生大量不连续的内存碎片，以后需要给大对象分配内存时，会提前触发一次垃圾回收动作。

#### 复制算法（Copying）
将内存分为两等块，每次使用其中一块。当这一块内存用完后，就将还存活的对象复制到另外一个块上，然后再把已使用过的内存空间一次清理掉。

![](https://images2015.cnblogs.com/blog/568153/201707/568153-20170713133054775-540568584.png)

优缺点：
1、无内存碎片问题，实现简单，时间效率高。
2、空间利用率低，可用内存缩小为原来的一半。

适合于每次回收时大量对象死去只有少量存活的情况，如年轻代中。

#### 标记-整理算法（Mark-Compact）
标记过程与标记 - 清除算法一样，但之后让所有存活的对象移向一端，然后直接清理掉边界以外的内存。

![](https://images2015.cnblogs.com/blog/568153/201707/568153-20170713133101400-240030919.png)

适合对象存活率高的情况，如老年代中。无需考虑内存碎片问题。

#### 分代收集算法（Generational Collection）
根据对象存活周期将堆分为新生代和老年代，然后根据各年代特点选择适当的回收算法。

新生代基本上对象都是朝生暮死的，生存时间很短暂，因此可采用复制算法，只需要复制少量的对象就可以完成垃圾收集。

老年代中的对象存活率高，也没有额外的空间进行分配担保，因此必须使用标记-整理或者标记-清除算法进行回收，只需要清除少量对象即可完成垃圾收集。

## 垃圾收集器
垃圾收集算法是垃圾收集器的理论基础，而垃圾收集器就是其具体实现。下面介绍 HotSpot 虚拟机提供的几种垃圾收集器。

#### Serial/Serial Old
最古老的收集器，是一个单线程收集器，用它进行垃圾回收时，必须暂停所有用户线程。Serial 是针对新生代的收集器，采用 Copying 算法；而 Serial Old 是针对老生代的收集器，采用 Mark-Compact 算法。优点是简单高效，缺点是需要暂停用户线程。

#### ParNew
Seral/Serial Old 的多线程版本，使用多个线程进行垃圾收集。

#### Parallel
Parallel Scavenge 是新生代的并行收集器，回收期间不需要暂停其他线程，采用 Copying 算法。该收集器与前两个收集器不同，主要为了达到一个可控的吞吐量。

#### Parallel Old
Parallel Scavenge 的老生代版本，采用 Mark-Compact 算法和多线程。

#### CMS
Current Mark Sweep 收集器是一种以最小回收时间停顿为目标的并发回收器，因而采用 Mark-Sweep 算法。

#### G1
G1（Garbage First）收集器技术的前沿成果，是面向服务端的收集器，能充分利用 CPU 和多核环境。是一款并行与并发收集器，它能够建立可预测的停顿时间模型。


#### 对比
|收集器|适用的代|采用的收集算法|适用的模式|串行、并行、并发|目标|
| :- |
|Serial|Young|复制|Client|用户线程停止，收集线程串行|GC时停顿时间少|
|Serial Old|Old|标记-整理|Client、Server|用户线程停止，收集线程串行|GC时停顿时间少|
|ParNew|Young|复制|Server|用户线程停止，收集线程并行|GC时停顿时间少|
|Parallel|Young|复制||用户线程停止、收集线程并行|吞吐量尽可能大|
|Parallel Old|Old|标记-整理||用户线程停止，收集线程并行|吞吐量尽可能大|
|CMS|Old|标记-清除||用户线程和收集线程均在执行，前者不用停止|GC时停顿时间少|
|G1|Young、Old|标记-整理|Server|用户线程和收集线程均在执行，前者不用停止|GC时停顿时间少|

JVM什么时候会触发YGC，什么时候触发FGC？

JVM如何内存调优、内存泄漏如何排查

https://www.cnblogs.com/z-sm/p/6243378.html

## 问题
## GC
谈谈 Java GC

GC 触发条件

GC 原理

JVM 的垃圾回收机制和垃圾收集器

说一下GC吧，什么时候进行Full GC呢？

jvm GC原理，JVM怎么回收内存

Java对象的回收方式，回收算法。

JVM有哪些回收算法，对应的收集器有哪些？

Minor GC与Full GC分别发生在什么时候

GC的三种三种收集方法：标记清除，标记整理，复制算法的原理与特点，分别用于什么地方，如果让你优化收集算法，有什么思路

#### 确认垃圾
GC 可达性分析中哪些算是GC ROOT？

GC的两种判定方法：引用计数器和引用链

#### 回收算法

JAVA的垃圾回收，标记算法和复制算法的区别，用在什么场合？

GC回收算法,及实现原理?

垃圾收集算法

JVM的垃圾回收算法有哪些

JVM GC算法有哪些，目前的JDK版本采用什么回收算法

有哪些回收算法，对应的收集器有哪些？

Java对象的回收方式，回收算法。

Java内存分代模型，GC算法，JVM常见的启动参数； CMS算法的过程。

说一下GC吧，什么时候进行Full GC呢？

内存泄漏与内存溢出的区别

GC、G1 和 ZGC 的区别

JAVA的垃圾回收，标记算法和复制算法的区别，用在什么场合？

JVM中的老年代在什么情况下会触发GC？

jvm虚拟机老年代什么情况下会发生gc，给你一个场景，一台4核8G的服务器，每隔两个小时就要出现一次老年代gc，现在有日志，怎么分析是哪里出了问题

java GC算法，什么时候会触发minor gc，什么时候会触发full gc？

新生代和老年代的回收机制。

什么时候fullGC？

目前的JDK使用的是什么垃圾回收算法，为什么要用这个算法？



讲一下JVM的分代回收以及具体算法



