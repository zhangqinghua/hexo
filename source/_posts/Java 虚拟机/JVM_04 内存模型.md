---
title: JVM_04 内存模型

categories:
- Java 虚拟机

date: 2020-01-01 00:00:04
---

Java 内存模型简称 JMM，定义了 JVM 在计算机内存中的工作方式。JVM 是整个计算机虚拟模型，所以 JMM 是隶属于 JVM 的。

## 并发编程
在并发编程领域，有两个关键问题：线程之间的通信和同步。

Java 的并发采用的是共享内存模型。

Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。

#### 线程之间的通信
线程的通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种，共享内存和消息传递。

在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。

在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在 Java 中典型的消息传递方式就是 `wait()` 和 `notify()`。

#### 线程之间的同步
同步是指程序用于控制不同线程之间操作发生相对顺序的机制。

在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。

在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。

## Java 内存模型
Java 线程之间的通信采用的是过共享内存模型，这里提到的共享内存模型指的就是 Java 内存模型（简称 JMM），JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIxMTgyMzM3OTA0?x-oss-process=image/format,png)

从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：
1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。
1. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。 

下面通过示意图来说明这两个步骤：

![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIxMTgyNzQ4NTUx?x-oss-process=image/format,png)

如上图所示，本地内存 A 和 B 有主内存中共享变量 x 的副本。假设初始时，这三个内存中的 x 值都为 0。线程 A 在执行时，把更新后的 x 值（假设值为 1）临时存放在自己的本地内存 A 中。当线程 A 和线程 B 需要通信时，线程 A 首先会把自己本地内存中修改后的 x 值刷新到主内存中，此时主内存中的x值变为了 1。随后，线程B到主内存中去读取线程 A 更新后的 x 值，此时线程B的本地内存的 x 值也变为了 1。

从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 Java 程序员提供内存可见性保证。

## JVM 对 Java 内存模型的实现
在 JVM 内部，Java 内存模型把内存分成了两部分：线程栈区和堆区，下图展示了 Java 内存模型在 JVM 中的逻辑视图：

![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIxMTgyODM3Njk3?x-oss-process=image/format,png)

JVM 中运行的每个线程都拥有自己的线程栈，线程栈包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。

线程栈还包含了当前方法的所有本地变量信息。一个线程只能读取自己的线程栈，也就是说，线程中的本地变量对其它线程是不可见的。即使两个线程执行的是同一段代码，它们也会各自在自己的线程栈中创建本地变量，因此，每个线程中的本地变量都会有自己的版本。

所有原始类型（`boolean`，`byte`，`short`，`char`，`int`，`long`，`float`，`double`）的本地变量都直接保存在线程栈当中，对于它们的值各个线程之间都是独立的。对于原始类型的本地变量，一个线程可以传递一个副本给另一个线程，当它们之间是无法共享的。

堆区包含了 Java 应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如 `Byte`、`Integer`、`Long` 等等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。

下图展示了调用栈和本地变量都存储在栈区，对象都存储在堆区：

![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIxMTgyOTAzODE4?x-oss-process=image/format,png)

一个本地变量如果是原始类型，那么它会被完全存储到栈区。

一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。

对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。

对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。

`static` 类型的变量以及类本身相关信息都会随着类本身存储在堆区。

堆中的对象可以被多线程共享。如果一个线程获得一个对象的应用，它便可访问这个对象的成员变量。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于本地变量，每个线程都会拷贝一份到自己的线程栈中。

下图展示了上面描述的过程：

![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIxMTgyOTQ4NjAx?x-oss-process=image/format,png)

#### 共享对象的可见性
当多个线程同时操作同一个共享对象时，如果没有合理的使用 `volatile` 和 `synchronization` 关键字，一个线程对共享对象的更新有可能导致其它线程不可见。

想象一下我们的共享对象存储在主存，一个 CPU 中的线程读取主存数据到 CPU 缓存，然后对共享对象做了更改，但 CPU 缓存中的更改后的对象还没有 flush 到主存，此时线程对共享对象的更改对其它 CPU 中的线程是不可见的。最终就是每个线程最终都会拷贝共享对象，而且拷贝的对象位于不同的 CPU 缓存中。

下图展示了上面描述的过程。左边 CPU 中运行的线程从主存中拷贝共享对象 obj 到它的 CPU 缓存，把对象 obj 的 count 变量改为 2。但这个变更对运行在右边 CPU 中的线程不可见，因为这个更改还没有 flush 到主存中：

![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIxMTgzMjE4NjUx?x-oss-process=image/format,png)

要解决共享对象可见性这个问题，我们可以使用 Java `volatile` 关键字。Java `volatile` 关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存。`volatile` 原理是基于 CPU 内存屏障指令实现的，后面会讲到。

#### 竞争现象
如果多个线程共享一个对象，如果它们同时修改这个共享对象，这就产生了竞争现象。

如下图所示，线程 A 和线程 B 共享一个对象 obj。假设线程 A 从主存读取 Obj.count 变量到自己的 CPU 缓存，同时，线程 B 也读取了 Obj.count 变量到它的 CPU 缓存，并且这两个线程都对 Obj.count 做了加 1 操作。此时，Obj.count 加 1 操作被执行了两次，不过都在不同的 CPU 缓存中。

如果这两个加 1 操作是串行执行的，那么 Obj.count 变量便会在原始值上加 2，最终主存中的 Obj.count 的值会是 3。然而下图中两个加 1 操作是并行的，不管是线程 A 还是线程 B 先 flush 计算结果到主存，最终主存中的 Obj.count 只会增加 1 次变成 2，尽管一共有两次加 1 操作。

![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIxMTgzMjUxODcw?x-oss-process=image/format,png)

要解决上面的问题我们可以使用 Java `synchronized` 代码块。`synchronized` 代码块可以保证同一个时刻只能有一个线程进入代码竞争区，`synchronized` 代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会 flush 到主存，不管这些变量是不是 `volatile` 类型的。


## 并发编程的问题
## 共享内存模型
## 同步问题
## volatile 关键字

## 问题
1. 讲一下 Java 内存模型

1. jvm内存模型jmm 知道的全讲讲

1. jmm缓存模型如何调优?